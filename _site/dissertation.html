<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Contextual Trust Study</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
#rmd-source-code {
  display: none;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="melt_cast.html">Melting &amp; Casting</a>
</li>
<li>
  <a href="simulation.html">Simulating An RM Study</a>
</li>
<li>
  <a href="dissertation.html">Contextual Trust Study</a>
</li>
<li>
  <a href="scientific_articles.html">Scientific Publications</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="mailto:timothy.carsel@gmail.com">
    <span class="fa fa-envelope"></span>
     
  </a>
</li>
<li>
  <a href="https://www.linkedin.com/in/timcarsel/">
    <span class="fa fa-linkedin"></span>
     
  </a>
</li>
<li>
  <a href="https://twitter.com/TCarsel">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Contextual Trust Study</h1>

</div>


<div id="brief-rationale-of-my-study" class="section level1">
<h1>Brief Rationale of my study</h1>
<p>Interpersonal trust is an important facet of relationships, but current theories and research paradigms on interpersonal trust may be incomplete. Trust has traditionally been studied as either a trait of the individual or a facet of a specific relationship between two people. Although both approaches highlight different and important aspects of the psychology of trust, both approaches are limited in their ability to uncover more minute dynamics.</p>
<p>In my dissertation, I proposed and tested a goal-specific theory of interpersonal trust, the Interdependent Goal Model of Interpersonal Trust (IGM). I argued that the trust between two people varies across the interdependent goals that are shared within a relationship and that this variability is important for understanding interpersonal relationships.</p>
<p>Testing the hypotheses derived from the IGM required a methodology sensitive to the idiosyncratic goals and relationships of the participants. To this end, I employed a novel and ideographically-tailored survey in which participants described their current goals and best friend. After participants described their goals and best friend, they were asked to what extent they would trust their best friend across some of their most and least important goals.</p>
<p>On this page, I will walk you through the logic and main findings of my dissertation, including all necessary data pre-processing steps and my analyses. If you’re interested in a more detailed account of my theory, hypotheses, and methods, then I encourage you to read my dissertation <a href="Carsel_2020_Interdependent%20goal%20model%20of%20trust.pdf">here</a> <br/><br/><br/><br/></p>
</div>
<div id="hypotheses" class="section level1">
<h1>Hypotheses</h1>
<ul>
<li><p>The first hypothesis of the present study is that interpersonal trust will increase as the relevance of a best friend’s strength to a given task increases, and interpersonal trust will decrease as the relevance of a best friend’s weakness to a given task increases.</p></li>
<li><p>The second hypothesis of the present study is that individuals will place lower trust in another person on average across a range of highly important goals relative to goals of lower importance.</p></li>
<li><p>The third hypothesis of the present study is that for more important goals, people will be more likely to trust an important relational partner (e.g., best friend) if they believe the trustee’s strengths are relevant to the task and less likely to trust that relational partner if they believe the trustee’s weaknesses are relevant to the task. For goals that are less important, beliefs about the trustee’s strengths and weaknesses will be less relevant. <br/><br/><br/><br/></p></li>
</ul>
</div>
<div id="survey-methodology-overview" class="section level1">
<h1>Survey Methodology Overview</h1>
<p>In order to understand any analysis, it’s important to first understand the data generation process. In the case of these data, participants completed an idiographically-tailored survey.</p>
<p>A traditional survey uses what’s called a <strong>nomothetic</strong> approach, which aims to understand how groups of people act. These are the kinds of surveys people take all the time. For example, if you’ve ever completed a customer satisfaction survey that asked you questions like “On a scale of 1 to 5, how satisfied were you with the service you received?”, then you have completed a nomothetically-designed survey.</p>
<p>By contrast, an <strong>idiographic</strong> approach aims to understand the idiosyncracies of the individual. An example of an idiographically-designed customer satisfaction survey question might be something more along the lines of “What was the most important part of the service you received for why you gave the rating you did?”, with an open-ended text box for people to write in their response. <br/><br/><br/></p>
<div id="method" class="section level2">
<h2>Method</h2>
<p>In idiographically-tailored survey from which we got our data, participants were asked about their goals and their best friend. Specifically, participants first listed the goals they were currently pursuing, and then they were asked to select their three most and three least important goals. Next, participants were asked to identify their best friend and their best friend’s most descriptive strength and weakness. Afterwards, participants were asked to what extent their best friend’s most descriptive strength and weakness were relevant to each of the participants’ three most and three least important goals. Finally, participants were asked to what extent they would trust their best friend across their three most and three least important goals. The criterion variable of this study, or the thing we want to predict, is the trust participants placed in their best friend across those six goals. <br/><br/><br/><br/></p>
</div>
</div>
<div id="data-pre-processing" class="section level1">
<h1>Data Pre-processing</h1>
<p>The first step in analyzing data in <code>R</code> is to set your working environment and then load your data and required packages. I have already done that in the background, so I encourage you to download the code for this page if you would like to see that step. I will only show one example of code for each pre-processing step to save precious internet space.</p>
<p>After you’ve set up your enviornment you can start pre-processing your data to get it into the necessary format for analyses. Below, I create a participant identification number (PIN) and set it as a factor. Then I rename the variables that identify exactly <em>how</em> important, on a 1 to 10 scale, participants viewed their three most and three least important goals.</p>
<pre class="r"><code># Creating a PIN
data1$PIN&lt;-seq(from=1, to=length(data1$Progress))
# Setting the variable as a factor for analyses
data1$PIN&lt;-as.factor(data1$PIN)


## Creating variables for the continuous measure of goal importance 
# Most Important Goals 
data1$g1Imp&lt;-(as.numeric(data1$Q5.2)-1)</code></pre>
<p>Next, I have to create the variables that indicate to what extent participants’ best friend’s most descriptive strength and weakness were to each of the six goals. Here is where we come across our first coding challenge.</p>
<p>Because this survey was idiographically-tailored, and participants could have identified anywhere from 6 to 25 goals, these data are what’s known as <strong>sparse</strong>. Sparse data has a lot of empty cells, and this was one of the sparsest data sets I’ve ever worked with. In this case, there was a single value for every participant scattered across 33 columns! I mean, take a look at this hot mess!</p>
<pre class="r"><code>head(data1[, 1311:1345])</code></pre>
<pre><code>##   Q14.1_1 Q14.1_1_TEXT Q14.1_2 Q14.1_2_TEXT Q14.1_3 Q14.1_3_TEXT Q14.1_4
## 1       4           NA      NA           NA      NA           NA      NA
## 2       2           NA      NA           NA      NA           NA      NA
## 3      NA           NA      NA           NA       3           NA      NA
## 4      NA           NA      NA           NA      NA           NA      NA
## 5       1           NA      NA           NA      NA           NA      NA
## 6      NA           NA      NA           NA      NA           NA       1
##   Q14.1_4_TEXT Q14.1_5 Q14.1_5_TEXT Q14.1_6 Q14.1_7 Q14.1_8 Q14.1_9 Q14.1_10
## 1           NA      NA           NA      NA      NA      NA      NA       NA
## 2           NA      NA           NA      NA      NA      NA      NA       NA
## 3           NA      NA           NA      NA      NA      NA      NA       NA
## 4           NA      NA           NA      NA       5      NA      NA       NA
## 5           NA      NA           NA      NA      NA      NA      NA       NA
## 6           NA      NA           NA      NA      NA      NA      NA       NA
##   Q14.1_11 Q14.1_12 Q14.1_13 Q14.1_14 Q14.1_15 Q14.1_16 Q14.1_17 Q14.1_18
## 1       NA       NA       NA       NA       NA       NA       NA       NA
## 2       NA       NA       NA       NA       NA       NA       NA       NA
## 3       NA       NA       NA       NA       NA       NA       NA       NA
## 4       NA       NA       NA       NA       NA       NA       NA       NA
## 5       NA       NA       NA       NA       NA       NA       NA       NA
## 6       NA       NA       NA       NA       NA       NA       NA       NA
##   Q14.1_19 Q14.1_20 Q14.1_21 Q14.1_22 Q14.1_23 Q14.1_24 Q14.1_25 Q14.1_26
## 1       NA       NA       NA       NA       NA       NA       NA       NA
## 2       NA       NA       NA       NA       NA       NA       NA       NA
## 3       NA       NA       NA       NA       NA       NA       NA       NA
## 4       NA       NA       NA       NA       NA       NA       NA       NA
## 5       NA       NA       NA       NA       NA       NA       NA       NA
## 6       NA       NA       NA       NA       NA       NA       NA       NA
##   Q14.1_27 Q14.1_28 Q14.1_29 Q14.1_30
## 1       NA       NA       NA       NA
## 2       NA       NA       NA       NA
## 3       NA       NA       NA       NA
## 4       NA       NA       NA       NA
## 5       NA       NA       NA       NA
## 6       NA       NA       NA       NA</code></pre>
<p>Here is the code I used to condense that sparse data into a set of variables so that every participants’ value was included in a single variable.</p>
<pre class="r"><code>### Creating Goal Relevance Variables 
## Most Important Goals ##########
# Goal 1 Strength
data1$Goal1StrRel&lt;-(apply(data1[, 1311:1345], 1, function(x) x[!is.na(x)][1]))-1</code></pre>
<p>Let’s see if that worked.</p>
<pre class="r"><code>head(data1$Goal1StrRel:data1$Goal6StrRel)</code></pre>
<pre><code>## [1] 3 2</code></pre>
<p>Great! Now we have condensed our first set of predictors, and it’s time to move onto the next set of variables.</p>
<p>The variables that contained participants’ trust in their best friend across each goal was similarly sparse, so I simply applied the same code to fix that here. However, the measures for goal-specific trust were a bit more complicated, so they require more code. Specifically, participants were first asked if they trusted their best friend or not for each goal, and then they were asked to what extent they trusted or distrusted their best friend, depending on whether they first selcted trust or distrust. Because we was a continuous measure for our analyses, we need to somehow combine those extent variables with the dichotomous measure. Below is the code for how I accomplished that.</p>
<pre class="r"><code>### Creating Goal-Based Trust DVs ###
## Trust for Project 1 
# Trust
data1$Goal1TrustDi&lt;-(apply(data1[, 1731:1765], 1, function(x) x[!is.na(x)][1]))
# Extent Ss Trusts Best Friend for Project 1
data1$G1TrustExt&lt;-as.numeric(data1$Q26.2)
# Extent Ss distrusts Best Friend for Project 1
data1$G1DistrustExt&lt;-as.numeric(-data1$Q26.3)
# Lean Toward Trust vs Distrust
data1$G1TrustLean&lt;-as.numeric(data1$Q26.4)
# Creating bipolar measure of Trust-Distrust
data1$Goal1TrustBP&lt;-ifelse(data1$Goal1TrustDi==1,data1$G1TrustExt,
                           ifelse(data1$Goal1TrustDi==2,data1$G1DistrustExt,
                           ifelse(data1$G1TrustLean==1,1,
                           ifelse(data1$G1TrustLean==2,-1,NA))))

# Rely
data1$Goal1RelyDi&lt;-(apply(data1[, 1769:1803], 1, function(x) x[!is.na(x)][1]))
# Extent Ss Trusts Best Friend for Project 1
data1$G1RelyExt&lt;-as.numeric(data1$Q26.6)
# Extent Ss distrusts Best Friend for Project 1
data1$G1UnrelyDiExt&lt;-as.numeric(-data1$Q26.7)
# Lean Toward Trust vs Distrust
data1$G1RelyLean&lt;-as.numeric(data1$Q26.8)
# Creating bipolar measure of Trust-Distrust
data1$Goal1RelyBP&lt;-ifelse(data1$Goal1RelyDi==1,data1$G1RelyExt,
                           ifelse(data1$Goal1RelyDi==2,data1$G1UnrelyDiExt,
                           ifelse(data1$G1RelyLean==1,1,
                           ifelse(data1$G1RelyLean==2,-1,NA))))</code></pre>
<p>Whew!! That’s a lot! But we’re almost done. We have created our PIN, the continuous measure of goal mportance (for a manipulation check), the relevance of the best friend’s most descriptive strength and weakness to each goal, and the measure of goal-specific trust. All that is left is to create a subset of the data with only the variables that we need and to put it into the proper format.</p>
<p>Here, I subset the data and create the dataframme that I’ll use for plotting and my analyses</p>
<pre class="r"><code>data2&lt;-subset(data1,select=c(PIN:Goal1TrustDi,Goal1TrustBP,Goal1RelyDi,Goal1RelyBP,Goal2TrustDi,
                             Goal2TrustBP,Goal2RelyDi,Goal2RelyBP,Goal3TrustDi,Goal3TrustBP,Goal3RelyDi,
                             Goal3RelyBP,Goal4TrustDi,Goal4TrustBP,Goal4RelyDi,Goal4RelyBP,Goal5TrustDi,
                             Goal5TrustBP,Goal5RelyDi,Goal5RelyBP,Goal6TrustDi,Goal6TrustBP,Goal6RelyDi,
                             Goal6RelyBP)) </code></pre>
<p>Let’s check it to make sure everything worked properly</p>
<pre class="r"><code>str(data2)</code></pre>
<pre><code>## &#39;data.frame&#39;:    399 obs. of  43 variables:
##  $ PIN         : Factor w/ 399 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...
##  $ g1Imp       : num  9 9 9 7 7 9 7 9 9 9 ...
##  $ g2Imp       : num  8 9 9 9 8 7 5 7 9 8 ...
##  $ g3Imp       : num  8 9 9 9 7 9 8 9 9 7 ...
##  $ g4Imp       : num  6 7 9 4 3 7 6 6 5 5 ...
##  $ g5Imp       : num  6 7 9 2 2 5 7 4 4 5 ...
##  $ g6Imp       : num  5 1 9 6 2 7 3 3 6 3 ...
##  $ Goal1StrRel : num  3 1 2 4 0 0 0 4 3 0 ...
##  $ Goal1WeakRel: num  0 1 0 0 0 0 0 2 2 4 ...
##  $ Goal2StrRel : num  2 0 3 4 0 0 0 4 2 0 ...
##  $ Goal2WeakRel: num  1 0 2 0 0 0 0 2 1 4 ...
##  $ Goal3StrRel : num  0 2 0 1 0 0 2 4 2 0 ...
##  $ Goal3WeakRel: num  0 0 0 0 0 0 0 2 1 4 ...
##  $ Goal4StrRel : num  0 2 2 4 0 4 0 2 0 3 ...
##  $ Goal4WeakRel: num  1 0 2 0 0 2 0 0 0 0 ...
##  $ Goal5StrRel : num  2 0 4 2 0 4 0 2 0 0 ...
##  $ Goal5WeakRel: num  0 0 3 0 0 0 0 0 0 4 ...
##  $ Goal6StrRel : num  2 2 4 0 0 3 0 0 1 2 ...
##  $ Goal6WeakRel: num  0 1 2 0 0 0 0 0 1 0 ...
##  $ Goal1TrustDi: int  1 2 1 1 1 3 1 1 1 1 ...
##  $ Goal1TrustBP: num  4 -3 3 4 2 1 3 4 2 4 ...
##  $ Goal1RelyDi : int  1 3 3 1 2 1 1 1 3 1 ...
##  $ Goal1RelyBP : num  4 -1 1 4 -2 3 2 4 1 4 ...
##  $ Goal2TrustDi: int  1 2 1 1 3 1 3 1 1 1 ...
##  $ Goal2TrustBP: num  4 -3 4 4 1 3 1 4 2 4 ...
##  $ Goal2RelyDi : int  1 2 1 1 3 1 1 1 3 2 ...
##  $ Goal2RelyBP : num  4 -3 3 4 1 3 2 4 -1 -2 ...
##  $ Goal3TrustDi: int  1 1 2 2 3 2 1 1 1 2 ...
##  $ Goal3TrustBP: num  4 2 -1 -1 1 -2 3 4 3 -2 ...
##  $ Goal3RelyDi : int  1 1 3 2 3 2 1 1 1 2 ...
##  $ Goal3RelyBP : num  4 3 -1 -1 1 -3 3 4 2 -2 ...
##  $ Goal4TrustDi: int  1 1 1 1 2 1 3 1 3 1 ...
##  $ Goal4TrustBP: num  3 2 4 4 -4 4 -1 3 1 4 ...
##  $ Goal4RelyDi : int  1 1 1 1 2 1 2 1 3 1 ...
##  $ Goal4RelyBP : num  4 2 4 4 -4 4 -1 3 1 4 ...
##  $ Goal5TrustDi: int  1 1 1 3 1 1 3 3 3 1 ...
##  $ Goal5TrustBP: num  4 2 4 1 2 4 1 1 1 4 ...
##  $ Goal5RelyDi : int  1 1 1 1 1 1 1 3 3 2 ...
##  $ Goal5RelyBP : num  4 2 4 4 1 4 2 1 1 -2 ...
##  $ Goal6TrustDi: int  1 1 1 1 1 1 1 1 1 1 ...
##  $ Goal6TrustBP: num  4 2 4 3 2 2 2 3 3 4 ...
##  $ Goal6RelyDi : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ Goal6RelyBP : num  4 2 4 3 2 3 3 4 2 4 ...</code></pre>
<p>Perfect! Now, let’s arrange the variables for easier manipulation and set better names. In order to do this, we’ll need to convert our data from <strong>wide format</strong> to <strong>long format</strong>.</p>
<p>Most people are probably more familiar with <strong>wide format</strong>. In <strong>wide format</strong>, every column is a variable, and every row is a case or instance of the variable “participant.” In other words, each case represents a single participant. In <strong>long format</strong>, we stretch out our data so that each participant occupies multimple rows. In the end of this transformation, each row will be an instance or case of the variable “goal” so that every participant will occupy <strong>6</strong> rows, one for each of their three most and three least important goals.</p>
<pre class="r"><code>### Arranging columns for easier manipulation 
## Goal Importance 
# Select vars
impData&lt;-data2 %&gt;% dplyr::select(tidyselect::vars_select(names(data2), dplyr::matches(&#39;Imp&#39;)))
# Add PIN
impData$PIN&lt;-data2$PIN
# Wide to Long
impLong&lt;-impData %&gt;% gather(Goal,Importance,g1Imp:g6Imp)
# Rename factor levels
impLong$Goal&lt;-mapvalues(impLong$Goal, from = c(&quot;g1Imp&quot;,&quot;g2Imp&quot;,&quot;g3Imp&quot;,&quot;g4Imp&quot;,&quot;g5Imp&quot;,&quot;g6Imp&quot;),
                        to = c(&quot;Goal1&quot;,&quot;Goal2&quot;,&quot;Goal3&quot;,&quot;Goal4&quot;,&quot;Goal5&quot;,&quot;Goal6&quot;))

## Relevance of strength to each project 
# Select vars
strengthData&lt;-data2 %&gt;% dplyr::select(tidyselect::vars_select(names(data2), matches(&#39;StrRel&#39;)))
# Add PIN
strengthData$PIN&lt;-data2$PIN
# Wide to Long
srelLong&lt;-strengthData %&gt;% gather(Goal,StRel,Goal1StrRel:Goal6StrRel)
# Rename factor levels
srelLong$Goal&lt;-mapvalues(srelLong$Goal, from = c(&quot;Goal1StrRel&quot;,&quot;Goal2StrRel&quot;,&quot;Goal3StrRel&quot;,&quot;Goal4StrRel&quot;,&quot;Goal5StrRel&quot;,&quot;Goal6StrRel&quot;),
                         to = c(&quot;Goal1&quot;,&quot;Goal2&quot;,&quot;Goal3&quot;,&quot;Goal4&quot;,&quot;Goal5&quot;,&quot;Goal6&quot;))

## Relevance of weakness to each project 
# Select vars
weakData&lt;-data2 %&gt;% dplyr::select(tidyselect::vars_select(names(data2), matches(&#39;WeakRel&#39;)))
# Add PIN
weakData$PIN&lt;-data2$PIN
# Wide to Long
wrelLong&lt;-weakData %&gt;% gather(Goal,WeakRel,Goal1WeakRel:Goal6WeakRel)
# Rename factor levels
wrelLong$Goal&lt;-mapvalues(wrelLong$Goal, from = c(&quot;Goal1WeakRel&quot;,&quot;Goal2WeakRel&quot;,&quot;Goal3WeakRel&quot;,&quot;Goal4WeakRel&quot;,&quot;Goal5WeakRel&quot;,&quot;Goal6WeakRel&quot;),
                         to = c(&quot;Goal1&quot;,&quot;Goal2&quot;,&quot;Goal3&quot;,&quot;Goal4&quot;,&quot;Goal5&quot;,&quot;Goal6&quot;))

## Trust best friend 
# Select vars
trustData&lt;-data2 %&gt;% dplyr::select(tidyselect::vars_select(names(data2), matches(&#39;TrustBP&#39;)))
# Add PIN
trustData$PIN&lt;-data2$PIN
# Wide to Long
tLong&lt;-trustData %&gt;% gather(Goal,Trust,Goal1TrustBP:Goal6TrustBP)
# Rename factor levels
tLong$Goal&lt;-mapvalues(tLong$Goal, from = c(&quot;Goal1TrustBP&quot;,&quot;Goal2TrustBP&quot;,&quot;Goal3TrustBP&quot;,&quot;Goal4TrustBP&quot;,&quot;Goal5TrustBP&quot;,&quot;Goal6TrustBP&quot;),
                      to = c(&quot;Goal1&quot;,&quot;Goal2&quot;,&quot;Goal3&quot;,&quot;Goal4&quot;,&quot;Goal5&quot;,&quot;Goal6&quot;))

## Rely on best friend 
# Select vars
relyData&lt;-data2 %&gt;% dplyr::select(tidyselect::vars_select(names(data2), matches(&#39;RelyBP&#39;)))
# Add PIN
relyData$PIN&lt;-data2$PIN
# Wide to Long
rLong&lt;-relyData %&gt;% gather(Goal,Rely,Goal1RelyBP:Goal6RelyBP)
# Rename factor levels
rLong$Goal&lt;-mapvalues(rLong$Goal, from = c(&quot;Goal1RelyBP&quot;,&quot;Goal2RelyBP&quot;,&quot;Goal3RelyBP&quot;,&quot;Goal4RelyBP&quot;,&quot;Goal5RelyBP&quot;,&quot;Goal6RelyBP&quot;),
                      to = c(&quot;Goal1&quot;,&quot;Goal2&quot;,&quot;Goal3&quot;,&quot;Goal4&quot;,&quot;Goal5&quot;,&quot;Goal6&quot;))</code></pre>
<p>Now that we’ve created several smaller dataframes in <strong>long format</strong>, let’s merge them together to create a dataframe that’s in <strong>long format</strong> and has all of our variables. While we’re doing this, we will create a categorical variable that indicates whether a goal is one of the three most or three least important goals.</p>
<pre class="r"><code>### Creating Working Long Data
# Importance and Trust
imp.trust&lt;-merge(tLong,impLong,by=c(&quot;Goal&quot;,&quot;PIN&quot;))
# Adding rely
imp.trust.rely&lt;-merge(imp.trust,rLong,by=c(&quot;Goal&quot;,&quot;PIN&quot;))
# Adding relevance to strength
imp.trust.rely.str&lt;-merge(imp.trust.rely,srelLong,by=c(&quot;Goal&quot;,&quot;PIN&quot;))
# Adding relevance to weakness
data3&lt;-merge(imp.trust.rely.str,wrelLong,by=c(&quot;Goal&quot;,&quot;PIN&quot;))

# Converting goal variable to factor for analyses
data3$Goal&lt;-as.factor(data3$Goal)

# Adding Factor Indicating Most vs Least Important Projects
data3$impCat&lt;-ifelse(data3$Goal==&quot;Goal1&quot;, 1,
              ifelse(data3$Goal==&quot;Goal2&quot;, 1,
              ifelse(data3$Goal==&quot;Goal3&quot;, 1,
              ifelse(data3$Goal==&quot;Goal4&quot;, 0,
              ifelse(data3$Goal==&quot;Goal5&quot;, 0,
              ifelse(data3$Goal==&quot;Goal6&quot;, 0,NA))))))
# Converting to Factor
data3$impCat&lt;-as.factor(data3$impCat)

data3$impCat&lt;-factor(data3$impCat,
                     levels=c(0,1),
                     labels=c(&quot;Least Important&quot;,&quot;Most Important&quot;))</code></pre>
<p>Now let’s check our new dataframe to make sure all our variables are there and that they’re in the proper format.</p>
<pre class="r"><code>str(data3)

head(data3)

tail(data3)</code></pre>
<pre><code>## &#39;data.frame&#39;:    2394 obs. of  8 variables:
##  $ Goal      : Factor w/ 6 levels &quot;Goal1&quot;,&quot;Goal2&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ PIN       : Factor w/ 399 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 10 100 101 102 103 104 105 106 107 ...
##  $ Trust     : num  4 4 3 1 -1 4 2 3 3 4 ...
##  $ Importance: num  9 9 9 9 6 9 6 7 9 7 ...
##  $ Rely      : num  4 4 3 2 -3 4 2 4 1 4 ...
##  $ StRel     : num  3 0 0 0 0 3 3 2 3 0 ...
##  $ WeakRel   : num  0 4 0 0 1 0 0 3 0 1 ...
##  $ impCat    : Factor w/ 2 levels &quot;Least Important&quot;,..: 2 2 2 2 2 2 2 2 2 2 ...
##    Goal PIN Trust Importance Rely StRel WeakRel         impCat
## 1 Goal1   1     4          9    4     3       0 Most Important
## 2 Goal1  10     4          9    4     0       4 Most Important
## 3 Goal1 100     3          9    3     0       0 Most Important
## 4 Goal1 101     1          9    2     0       0 Most Important
## 5 Goal1 102    -1          6   -3     0       1 Most Important
## 6 Goal1 103     4          9    4     3       0 Most Important
##       Goal PIN Trust Importance Rely StRel WeakRel          impCat
## 2389 Goal6  94     3          4    4     1       0 Least Important
## 2390 Goal6  95    -3          4   -3     0       0 Least Important
## 2391 Goal6  96     1          3    2     2       0 Least Important
## 2392 Goal6  97    -2          4   -1     0       0 Least Important
## 2393 Goal6  98     4          4    4     0       0 Least Important
## 2394 Goal6  99    -1          7   -2     0       0 Least Important</code></pre>
<p>Now that we have the data in the appropriate format, we only have a couple more pre-processing steps. First, we need to center our predictor variables.</p>
<p>There are two ways I can choose to center my predictor variables, by <strong>participant</strong> or <strong>globally</strong>. <strong>Globally-centered</strong> variables will subtract the <strong>grand mean</strong>, or overall average of the variable, from each participant’s value. The end result will be that the average value of that variable across all participants will be 0. <strong>Participant-centered</strong> variables subtract <em>each participant’s</em> mean from each of their values. The end result of <em>this</em> process will be that the average for each participant on each variable is 0. Each of these centering strategies tells a different story, so it’s important to choose whichever one makes the most sense for your research question. In this case, <strong>participant-centered</strong> variables makes the most sense. So that’s what we’re going to do!</p>
<pre class="r"><code>## Centering IVs by Ss 
# Relevance to Strength
# Mean of Relevance to Strength
data3&lt;-ddply(data3,.(PIN), plyr::mutate, rStrMean = mean(StRel))
# Participant-centered Relevance to Strength
data3$StrRelC&lt;-data3$StRel-data3$rStrMean
# Globally-centered Relevance to Strength
data3$StrRel_GlobC &lt;- scale(data3$StRel, scale = FALSE)[,]</code></pre>
<p>Now that we’ve centered our predictors, let’s check whether our two questions that are to make up our composite measure of goal-specific trust are sufficiently correlated. In other words, I want to average the responses to the question “To what extent would you <em>trust</em> your best friend” with the responses to the question “To what extent would you be willing to <em>rely</em> on your best friend?” However, if these items do not actually measure the same thing (i.e., the correlation is really low), then I shouldn’t average them together. So let’s look real quick.</p>
<pre class="r"><code>cor.test(data3$Trust,data3$Rely, use = &quot;pairwise.complete.obs&quot;)</code></pre>
<pre><code>## 
##  Pearson&#39;s product-moment correlation
## 
## data:  data3$Trust and data3$Rely
## t = 62.764, df = 2378, p-value &lt; 2.2e-16
## alternative hypothesis: true correlation is not equal to 0
## 95 percent confidence interval:
##  0.7740460 0.8043255
## sample estimates:
##       cor 
## 0.7896661</code></pre>
<p>Ok. They’re correlated at about 0.80, which is not the best, but it does fall within the range that most consider appropriate for averaging. So, now I’ll do that here.</p>
<pre class="r"><code>data3$trustRely &lt;- (data3$Trust+data3$Rely)/2</code></pre>
<p>Perfect! Now we’re ready to explore and analyzing our data! <br/><br/><br/><br/></p>
</div>
<div id="plotting" class="section level1">
<h1>Plotting</h1>
<p>A central tenet of the theory I’m testing is that trust is not static across the contours of a relationship. In other words, people can trust and distrust the same person depending on the goal. If that’s true, then we should be able to see it in our data. Below, I randomly select 4 participants and plot the trust they place in their best friend across their three most and least important goals</p>
<p><img src="dissertation_files/figure-html/unnamed-chunk-20-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p>B-e-a-utiful!! Whereas some people seem to be pretty consistent in their trust in their best friend, others appear to calibrate their trust in their friend across the goals in their lives.</p>
<p>Now that we’ve checked to see whether this was all probably a waste of time or whether there might be somemthing there, let’s check out the other variables. <br/><br/><br/></p>
<div id="histograms" class="section level2">
<h2>Histograms</h2>
<p>Ok, now that we’ve centered our data, let’s take a look at the histograms of our variables. First, let’s look at the distribution of the relevance to strength measure. <br/><br/><br/></p>
<div id="relevance-to-strength" class="section level3">
<h3>Relevance to Strength</h3>
<p><img src="dissertation_files/figure-html/unnamed-chunk-21-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p>That loooks decent. It’s a bit positively-skewed, which means that their are more values on the lower end of the scale than the higher end, but it doesn’t look terrible. Now let’s take a look at the relevance to weakness measure <br/><br/></p>
</div>
<div id="relevance-to-weakness" class="section level3">
<h3>Relevance to Weakness</h3>
<p><img src="dissertation_files/figure-html/unnamed-chunk-22-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p>That is <em>much</em> worse. Notice how nearly all of the values are at the lowest end of the scale? Not only is this extremely positively-skewed, it also looks like we’re seeing a <strong>floor effect</strong>. A <strong>Floor effect</strong> is when the distribution of your variable is clustered at the lower bound of the variable range. This is not a good distribution, and it tells us that any potential failure to find an effect may be due to the hypothesis <em>or</em> the <strong>floor effect</strong>. That’s not good, but it is what we have, so we’ll see what we see.</p>
<p>Finally, let’s check out the distribution of the continuous measure of goal importance. <br/><br/></p>
</div>
<div id="goal-importance" class="section level3">
<h3>Goal Importance</h3>
<p><img src="dissertation_files/figure-html/unnamed-chunk-23-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p>In contrast to the last two histograms, this variable is a bit <strong>negatively-skewed</strong>, which means that most of the values are at the higher end of the scale. However, like the relevance to strength measure, this distribution is not worrisome.</p>
<p>Now that we’ve checked the distributions of our predictor variables, let’s plot out the relationships we plan to test. <br/><br/><br/></p>
</div>
</div>
<div id="predicted-relationships" class="section level2">
<h2>Predicted Relationships</h2>
<p>Before we plot the hypothesized relationships, let’s first check to make sure that participants’ most important goals were actually more important than their least important goals. <br/><br/></p>
<div id="manipulation-check" class="section level3">
<h3>Manipulation Check</h3>
<p><img src="dissertation_files/figure-html/unnamed-chunk-24-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p>Perfect. Participants completed the study as expected! Now let’s check out our hypotheses.</p>
<p>The first hypothesis was that participants would trust their best friend less for more important than less important goals. Let’s see if that’s what the relationship looks like. <br/><br/></p>
</div>
<div id="trust-by-importance" class="section level3">
<h3>Trust By Importance</h3>
<p><img src="dissertation_files/figure-html/unnamed-chunk-25-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p>Well, there doesn’t appear to be much of a relationship there. In fact, it kinda looks like the slope is in the opposite direction than predicted. This is definitely something to look for in the stats we’ll run in a bit.</p>
<p>The second hypothesis was that participants would trust their best friend <em>more</em> the more their friend’s strength was relevant to the goal. Let’s take a look. <br/><br/></p>
</div>
<div id="trust-by-strength" class="section level3">
<h3>Trust By Strength</h3>
<p><img src="dissertation_files/figure-html/unnamed-chunk-26-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p>That looks like a strong relationship in the direction we predicted! Yay!!</p>
<p>The third prediction was that participants would trust their best friend <em>less</em> the more their friend’s weakness was relevant to the goal. <br/><br/></p>
</div>
<div id="trust-by-weakness" class="section level3">
<h3>Trust By Weakness</h3>
<p><img src="dissertation_files/figure-html/unnamed-chunk-27-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p>That looks like a weak relationship but again in the opposite direction than predicted. This is another finding we’ll keep a sharp eye on in our analyses.</p>
<p>The final two hypotheses were that the relationships between the relevance to strength and the relevance to weakness on goal-specific trust would only show up for more important goals. There should be no relationship between the relevance to strength and the relevance to weakness on goal-specific trust for less important goals. Next I plot those predictions. We’ll first take a look at the interaction between goal importance and the relevance to strength before examining the interaction between goal importance and the relevance to weakness. <br/><br/></p>
</div>
<div id="interactions" class="section level3">
<h3>Interactions</h3>
<p><img src="dissertation_files/figure-html/unnamed-chunk-28-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p><img src="dissertation_files/figure-html/unnamed-chunk-29-1.png" width=".49\linewidth" style="display: block; margin: auto;" /></p>
<p>Welp. It looks like neither prediction was supported. Time to go run the statistical analyses to check what our graphs are telling us. <br/><br/><br/><br/></p>
</div>
</div>
</div>
<div id="analyses" class="section level1">
<h1>Analyses</h1>
<p>Now that we’ve graphed our data and gotten insight into our variables’ distributions and the relationships between our predictor and criterion variables, it’s time to run statistical analyses to formally test our hypotheses.</p>
<p>The analyses that I will do below are linear multilevel (or mixed effects) models (MLMs). These analyses will allow me to model the random variance that is caused by our participants reporting different average levels of trust in their best friend (random intercept) and different relationships betweeen goal importance and goal-specific trust (random slope).</p>
<p>As a side note, the most appropriate analyses for these data are actually ordinal logistic multilevel models. The criterion variable, goal-specific trust, is on an <strong>ordinal scale</strong>. Ordinal scales are where the distance between scale points are not even. By contrast, in <strong>interval</strong> or <strong>ratio scales</strong>, the distance between scale points is the same. An example of an interval scale is temperature in degrees Fahrenheit. The difference between 1<span class="math inline">\(^\circ\)</span> and 2<span class="math inline">\(^\circ\)</span> Fahrenheit is the same as the difference between 101<span class="math inline">\(^\circ\)</span> and 102<span class="math inline">\(^\circ\)</span> Fahrenheit. By contrast, is the difference between “slightly trust” and “moderately trust” the same as the difference between “moderately trust” and “very much trust?” I don’t know, but probably not. Technically, linear MLMs require interval or ratio criterion variables whereas ordinal logistic MLMs require ordinal criterion variables. However, I ran both sets of analyses, and the conclusions remain the same. Consequently, I demonstrate linear MLMs here because they are generally easier to understand.</p>
<p>These analyses are a bit complicated and require us to carefully monitor changes in our output as a funciton of changes in our fixed and random effects. I will explain each step. <br/><br/><br/></p>
<div id="random-effects" class="section level2">
<h2>Random Effects</h2>
<p>The first step in running MLMs is to examine your random structure. To do this, we will include only the criterion variable and an intercept in our model and systematically change our random effects. This part might be a bit easier to understand while doing it than me explaining it, so let’s just dive right in.</p>
<p>In this first model, I am going to use what’s called the maximal random structure. The maximal structure includes the random intercept <em>and</em> the random slope, and is our best model at reducing our Type I error rate (which is the probability of incorrectly saying there is a real effect when there is in fact no effect).</p>
<pre class="r"><code>max_random &lt;- lmer(Importance ~ 1
         + (1+dummy(impCat)|PIN), data = data3, REML=F)
summary(max_random)</code></pre>
<pre><code>## Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s
##   method [lmerModLmerTest]
## Formula: Importance ~ 1 + (1 + dummy(impCat) | PIN)
##    Data: data3
## 
##      AIC      BIC   logLik deviance df.resid 
##   9518.6   9547.5  -4754.3   9508.6     2389 
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -4.7602 -0.5828  0.1264  0.7316  3.3925 
## 
## Random effects:
##  Groups   Name          Variance Std.Dev. Corr 
##  PIN      (Intercept)   10.646   3.263         
##           dummy(impCat) 13.094   3.619    -0.99
##  Residual                1.828   1.352         
## Number of obs: 2394, groups:  PIN, 399
## 
## Fixed effects:
##              Estimate Std. Error        df t value Pr(&gt;|t|)    
## (Intercept)   7.47524    0.03965 398.99529   188.5   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## convergence code: 0
## Model failed to converge with max|grad| = 0.00216772 (tol = 0.002, component 1)</code></pre>
<p>The first thing you should note is the warning that the model failed to converge. This means that the maximum likelihood estimation process (beyond the scope of this explanation) failed. A wise person once told me that a model that does not work cannot be the correct model. Although we’re getting numbers here, it’s probably best to reduce our random structure. The second thing to note is that the correlaiton between the random intercept and the random slope is very high (-0.99). A perfect correlation (+/- 1.00) is very bad for our model, so that gives us further reason to reduce our random structure.</p>
<p>The very first change I like to make is to block the correlation between the random slope and intercept. This removes a single feature from our random effects, so it is a desirable first step. To do this, I’m just going to add another <code>|</code> in the random effects portion of the model, like this.</p>
<pre class="r"><code>no_cor_random &lt;- lmer(Importance ~ 1
         + (1+dummy(impCat)||PIN), data = data3, REML=F)
summary(no_cor_random)</code></pre>
<pre><code>## Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s
##   method [lmerModLmerTest]
## Formula: Importance ~ 1 + (1 + dummy(impCat) || PIN)
##    Data: data3
## 
##      AIC      BIC   logLik deviance df.resid 
##  10056.3  10079.5  -5024.2  10048.3     2390 
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -3.8756 -0.5501  0.1163  0.5550  3.2275 
## 
## Random effects:
##  Groups   Name          Variance Std.Dev.
##  PIN      (Intercept)    1.822   1.350   
##  PIN.1    dummy(impCat) 11.937   3.455   
##  Residual                1.868   1.367   
## Number of obs: 2394, groups:  PIN, 399
## 
## Fixed effects:
##              Estimate Std. Error        df t value Pr(&gt;|t|)    
## (Intercept)   4.69898    0.07781 395.17704   60.39   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>That worked! Notice how we didn’t get anymore errors? This random structure does seem to fit our data a bit better. I also want you to notice that the residual variance increased ever so slightly. That’s because we removed a random effect that was accounting for some of the variance (the correlation between the random slope and intercept). It’s important to keep a close eye on your residuals as you explore different model fits.</p>
<p>Depending on the training you’ve received in MLMs, some would stop examining the random structure here. The argument goes that every reduction in the random structure has a potential (or inevitable) increase in the Type I error rate. However, I use parsimonious fitting (Bates, Kliegl, Vasishth, &amp; Baayen, 2015) to systematically reduce the random terms and find the simplest model that does not sacrifice model fit. To do so, I will remove random effects one at a time and see the potential change in the residual of the model. The moment a model fits significantly worse, as determined by a Chi-square, I will stop and keep the more complex model. This process can be long, and it is indeed long for these data, so I will only show the first step.</p>
<p>In this first step, I am going to remove the random intercept. To execute this step, I simply need to change the “1” in my random effects portion to “0.” Let’s see what happens.</p>
<pre class="r"><code>no_intercept_random &lt;- lmer(Importance ~ 1
         + (0+dummy(impCat)||PIN), data = data3, REML=F)
summary(no_intercept_random)</code></pre>
<pre><code>## Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s
##   method [lmerModLmerTest]
## Formula: Importance ~ 1 + (0 + dummy(impCat) || PIN)
##    Data: data3
## 
##      AIC      BIC   logLik deviance df.resid 
##  10423.2  10440.5  -5208.6  10417.2     2391 
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.9456 -0.4826  0.0856  0.6538  2.3584 
## 
## Random effects:
##  Groups   Name          Variance Std.Dev.
##  PIN      dummy(impCat) 9.239    3.04    
##  Residual               3.098    1.76    
## Number of obs: 2394, groups:  PIN, 399
## 
## Fixed effects:
##              Estimate Std. Error        df t value Pr(&gt;|t|)    
## (Intercept) 4.849e+00  4.849e-02 2.277e+03     100   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Notice that the residual variance increased by a lot?! That probably means this model is not as good a fit. Let’s formally test our intuition.</p>
<pre class="r"><code>anova(no_cor_random, no_intercept_random)</code></pre>
<pre><code>## Data: data3
## Models:
## no_intercept_random: Importance ~ 1 + (0 + dummy(impCat) || PIN)
## no_cor_random: Importance ~ 1 + (1 + dummy(impCat) || PIN)
##                     Df   AIC   BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)
## no_intercept_random  3 10423 10440 -5208.6    10417                         
## no_cor_random        4 10056 10080 -5024.2    10048 368.85      1  &lt; 2.2e-16
##                        
## no_intercept_random    
## no_cor_random       ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>As expected, the no intercepts model fits significantly worse. Normally, that would mean that I would keep the more complex model. However, when I added in the main effects, those models failed to converge with the more complex random structures. After hours of pouring through many many models, it turned out that the simplest model was the only one that converged across all analyses. Because you <em>must</em> have the same random structure to compare between models, that is the structure I will use here. The final random structure, then, only includes a random intercept.</p>
<p>Now that we’ve examined our random structure, let’s start actually testing our hypotheses. <br/><br/><br/></p>
</div>
<div id="fixed-effects" class="section level2">
<h2>Fixed effects</h2>
<p>In MLMs, fixed effects refer to the effects of interest. In other words, our fixed effects are the relationships between our predictor variables and our criterion variable. In the case of this study, our fixed effects are <strong>goal importance</strong>, <strong>relevance to strength</strong>, <strong>relevance to weakness</strong>, and the two-way interactions between <strong>goal importance</strong> and the two <strong>relevance</strong> variables. We will need four different models to examine all of our hypotheses, starting with a model that only includes the main effects of our predictor variables.</p>
<pre class="r"><code>main_effects &lt;- lmer(trustRely ~ WeakRelC + StrRelC + impCat
                         + (1|PIN), data = data3, REML=F)
summary(main_effects)</code></pre>
<pre><code>## Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s
##   method [lmerModLmerTest]
## Formula: trustRely ~ WeakRelC + StrRelC + impCat + (1 | PIN)
##    Data: data3
## 
##      AIC      BIC   logLik deviance df.resid 
##   9781.3   9815.9  -4884.7   9769.3     2328 
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -3.3030 -0.5081  0.1819  0.6311  2.3093 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  PIN      (Intercept) 1.081    1.040   
##  Residual             3.200    1.789   
## Number of obs: 2334, groups:  PIN, 389
## 
## Fixed effects:
##                       Estimate Std. Error        df t value Pr(&gt;|t|)    
## (Intercept)          1.721e+00  7.439e-02 6.765e+02  23.128   &lt;2e-16 ***
## WeakRelC             8.599e-02  4.559e-02 1.945e+03   1.886   0.0594 .  
## StrRelC              4.748e-01  3.379e-02 1.945e+03  14.050   &lt;2e-16 ***
## impCatMost Important 1.708e-01  7.439e-02 1.945e+03   2.296   0.0218 *  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) WekRlC StrRlC
## WeakRelC     0.002              
## StrRelC      0.045 -0.281       
## impCtMstImp -0.500 -0.003 -0.089</code></pre>
<p>What do we notice? First, our relevance to strength measure strongly and significantly predicts goal-specific trust. This was the effect we noticed in our graphs above and confirms both our hypothesis and intuitions from the graph. Second, and in line with the graphs but against our hypothesis, goal importance is a significant and <em>positive</em> predictor of trust, and the relevance to weakness is a marginally (ugh, I hate that word too) significant and <em>positive</em> predictor of trust. I’m not going to go through the implications for the theory here, so I encourage you to read my dissertation, if you’re interested. :)</p>
<p>Next, let’s add each of the interactions in one-at-a-time. We will test whether the more complex model fits the data better than the simpler model after each step</p>
<pre class="r"><code>## Adding interaction between Strength and Importance
strength_importance &lt;- lmer(trustRely ~ WeakRelC + StrRelC*impCat
                                  + (1|PIN), data=data3, REML=F)
summary(strength_importance)
# The interaction is negative but not significant
anova(main_effects, strength_importance)
# Not a significant improvement in model fit
## Adding interaction between Weakness and Importance
weakness_importance&lt;-lmer(trustRely ~ WeakRelC*impCat + StrRelC
                                  + (1|PIN), data=data3, REML=F)
summary(weakness_importance)
# The interaction is not significant
anova(main_effects, weakness_importance)
# Not a significant improvement in model fit</code></pre>
<pre><code>## Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s
##   method [lmerModLmerTest]
## Formula: trustRely ~ WeakRelC + StrRelC * impCat + (1 | PIN)
##    Data: data3
## 
##      AIC      BIC   logLik deviance df.resid 
##   9782.8   9823.1  -4884.4   9768.8     2327 
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -3.3002 -0.5165  0.1820  0.6289  2.3274 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  PIN      (Intercept) 1.081    1.040   
##  Residual             3.199    1.789   
## Number of obs: 2334, groups:  PIN, 389
## 
## Fixed effects:
##                                Estimate Std. Error         df t value Pr(&gt;|t|)
## (Intercept)                     1.72340    0.07448  679.18622  23.139   &lt;2e-16
## WeakRelC                        0.08552    0.04559 1945.06710   1.876   0.0608
## StrRelC                         0.50142    0.04871 2126.10309  10.295   &lt;2e-16
## impCatMost Important            0.17086    0.07438 1945.00058   2.297   0.0217
## StrRelC:impCatMost Important   -0.05391    0.07093 2254.37899  -0.760   0.4474
##                                 
## (Intercept)                  ***
## WeakRelC                     .  
## StrRelC                      ***
## impCatMost Important         *  
## StrRelC:impCatMost Important    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) WekRlC StrRlC impCMI
## WeakRelC     0.001                     
## StrRelC      0.067 -0.205              
## impCtMstImp -0.499 -0.003 -0.061       
## StrRlC:mCMI -0.051  0.013 -0.720 -0.002
## Data: data3
## Models:
## main_effects: trustRely ~ WeakRelC + StrRelC + impCat + (1 | PIN)
## strength_importance: trustRely ~ WeakRelC + StrRelC * impCat + (1 | PIN)
##                     Df    AIC    BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)
## main_effects         6 9781.3 9815.9 -4884.7   9769.3                         
## strength_importance  7 9782.8 9823.1 -4884.4   9768.8 0.5775      1     0.4473
## Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s
##   method [lmerModLmerTest]
## Formula: trustRely ~ WeakRelC * impCat + StrRelC + (1 | PIN)
##    Data: data3
## 
##      AIC      BIC   logLik deviance df.resid 
##   9783.3   9823.6  -4884.7   9769.3     2327 
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -3.3006 -0.5072  0.1825  0.6291  2.3089 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  PIN      (Intercept) 1.08     1.039   
##  Residual             3.20     1.789   
## Number of obs: 2334, groups:  PIN, 389
## 
## Fixed effects:
##                                 Estimate Std. Error         df t value Pr(&gt;|t|)
## (Intercept)                      1.72072    0.07439  675.67170  23.132   &lt;2e-16
## WeakRelC                         0.09373    0.06581 2150.93808   1.424   0.1545
## impCatMost Important             0.17079    0.07439 1944.14933   2.296   0.0218
## StrRelC                          0.47470    0.03380 1944.19712  14.047   &lt;2e-16
## WeakRelC:impCatMost Important   -0.01581    0.09693 2284.15420  -0.163   0.8704
##                                  
## (Intercept)                   ***
## WeakRelC                         
## impCatMost Important          *  
## StrRelC                       ***
## WeakRelC:impCatMost Important    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) WekRlC impCMI StrRlC
## WeakRelC     0.012                     
## impCtMstImp -0.500 -0.001              
## StrRelC      0.045 -0.202 -0.089       
## WkRlC:mpCMI -0.016 -0.721 -0.002  0.011
## Data: data3
## Models:
## main_effects: trustRely ~ WeakRelC + StrRelC + impCat + (1 | PIN)
## weakness_importance: trustRely ~ WeakRelC * impCat + StrRelC + (1 | PIN)
##                     Df    AIC    BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)
## main_effects         6 9781.3 9815.9 -4884.7   9769.3                         
## weakness_importance  7 9783.3 9823.6 -4884.7   9769.3 0.0265      1     0.8706</code></pre>
<p>In contrast to our hypotheses, neither interaction is significant. However, we have one final model to test before we go home. We still need to test the model with both interactions included.</p>
<pre class="r"><code>## Adding both interactions for completeness
full_model &lt;- lmer(trustRely ~ WeakRelC*impCat + StrRelC*impCat
                       + (1|PIN), data=data3, REML=F)
summary(full_model)
# Neither interaction is significant
anova(strength_importance, full_model)
anova(weakness_importance, full_model)
# Not a significant improvement in model fit over either singular interaction models</code></pre>
<pre><code>## Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite&#39;s
##   method [lmerModLmerTest]
## Formula: trustRely ~ WeakRelC * impCat + StrRelC * impCat + (1 | PIN)
##    Data: data3
## 
##      AIC      BIC   logLik deviance df.resid 
##   9784.8   9830.8  -4884.4   9768.8     2326 
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -3.3009 -0.5184  0.1817  0.6294  2.3279 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  PIN      (Intercept) 1.082    1.040   
##  Residual             3.199    1.789   
## Number of obs: 2334, groups:  PIN, 389
## 
## Fixed effects:
##                                 Estimate Std. Error         df t value Pr(&gt;|t|)
## (Intercept)                    1.723e+00  7.449e-02  6.777e+02  23.137   &lt;2e-16
## WeakRelC                       8.304e-02  6.734e-02  2.156e+03   1.233   0.2177
## impCatMost Important           1.709e-01  7.437e-02  1.944e+03   2.297   0.0217
## StrRelC                        5.019e-01  4.982e-02  2.130e+03  10.075   &lt;2e-16
## WeakRelC:impCatMost Important  5.046e-03  1.009e-01  2.282e+03   0.050   0.9601
## impCatMost Important:StrRelC  -5.493e-02  7.382e-02  2.251e+03  -0.744   0.4569
##                                  
## (Intercept)                   ***
## WeakRelC                         
## impCatMost Important          *  
## StrRelC                       ***
## WeakRelC:impCatMost Important    
## impCatMost Important:StrRelC     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) WekRlC impCMI StrRlC WRC:CI
## WeakRelC     0.002                            
## impCtMstImp -0.499 -0.001                     
## StrRelC      0.066 -0.290 -0.060              
## WkRlC:mpCMI -0.002 -0.736 -0.001  0.211       
## impCtMI:SRC -0.048  0.213 -0.001 -0.735 -0.277
## Data: data3
## Models:
## strength_importance: trustRely ~ WeakRelC + StrRelC * impCat + (1 | PIN)
## full_model: trustRely ~ WeakRelC * impCat + StrRelC * impCat + (1 | PIN)
##                     Df    AIC    BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)
## strength_importance  7 9782.8 9823.1 -4884.4   9768.8                         
## full_model           8 9784.8 9830.8 -4884.4   9768.8 0.0025      1     0.9602
## Data: data3
## Models:
## weakness_importance: trustRely ~ WeakRelC * impCat + StrRelC + (1 | PIN)
## full_model: trustRely ~ WeakRelC * impCat + StrRelC * impCat + (1 | PIN)
##                     Df    AIC    BIC  logLik deviance  Chisq Chi Df Pr(&gt;Chisq)
## weakness_importance  7 9783.3 9823.6 -4884.7   9769.3                         
## full_model           8 9784.8 9830.8 -4884.4   9768.8 0.5534      1     0.4569</code></pre>
<p>The full model is not an improvement over either single interaction models. <br/><br/><br/><br/></p>
</div>
</div>
<div id="implications" class="section level1">
<h1>Implications</h1>
<p>So what did we learn? <strong>First, trust varies within a relationship, and that variability is predictable.</strong></p>
<p>Second, the main effects only model was the best fit for the data. Consequently, in contrast to our hypotheses, neither of the interactions between <strong>relevance</strong> and <strong>goal importance</strong> predict goal-specific trust.</p>
<p>Third, <strong>relevance to weakness</strong> does not significantly predict trust, and <strong>goal importance</strong> positively predicts trust, both of which are counter to expectations.</p>
<p>Fourth and finally, and in line with predictions, <strong>relevance to strength</strong> strongly and positively predicts trust. <br/><br/><br/><br/></p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>I hope you have enjoyed and learned something from this overview and walkthrough of my dissertation logic and analyses! Please feel free to contact me if you’re interested in trust, the stats presented here, or just to have a friendly chat!! I love meeting new people and nerding out on these topics.</p>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIkNvbnRleHR1YWwgVHJ1c3QgU3R1ZHkiDQpvdXRwdXQ6DQogIGh0bWxfZG9jdW1lbnQ6DQogICAgY29kZV9kb3dubG9hZDogeWVzDQogICAgZm9udHNpemU6IDhwdA0KICAgIGhpZ2hsaWdodDogdGV4dG1hdGUNCiAgICBudW1iZXJfc2VjdGlvbnM6IG5vDQogICAgdGhlbWU6IGZsYXRseQ0KICAgIHRvYzogeWVzDQogICAgdG9jX2Zsb2F0Og0KICAgICAgY29sbGFwc2VkOiBubw0KLS0tDQoNCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQ0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KGNhY2hlID0gVFJVRSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVFJVRSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldChtZXNzYWdlID0gRkFMU0UpDQprbml0cjo6b3B0c19jaHVuayRzZXQod2FybmluZyA9ICBGQUxTRSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldChmaWcud2lkdGg9My4yNSkNCmtuaXRyOjpvcHRzX2NodW5rJHNldChmaWcuaGVpZ2h0PTIuNzUpDQprbml0cjo6b3B0c19jaHVuayRzZXQoZmlnLmFsaWduPSdjZW50ZXInKSANCmtuaXRyOjpvcHRzX2NodW5rJHNldChyZXN1bHRzPSdob2xkJykgDQpgYGANCg0KYGBge3IsIGVjaG89RkFMU0UsIHdhcm5pbmc9RkFMU0V9DQpsaWJyYXJ5KHBzeWNoKQ0KbGlicmFyeShsbWU0KQ0KbGlicmFyeShwbHlyKQ0KbGlicmFyeSh0aWR5dmVyc2UpDQpsaWJyYXJ5KGdncGxvdDIpDQpsaWJyYXJ5KGdnc3RhdHNwbG90KQ0KbGlicmFyeShkYXRhLnRhYmxlKQ0KbGlicmFyeShnbW9kZWxzKQ0KbGlicmFyeSh0ZXhyZWcpDQpsaWJyYXJ5KGxtZXJUZXN0KQ0KbGlicmFyeShhcGFUYWJsZXMpDQoNCmBgYA0KDQpgYGB7ciwgZWNobz1GQUxTRSwgd2FybmluZz1GQUxTRX0NCmRhdGExPC1yZWFkLmNzdigiRGlzc2VydGF0aW9uX0lkaW9UcnVzdC5jc3YiLCBoZWFkZXIgPSBULCBuYS5zdHJpbmdzID0gYygiIikpDQpgYGANCg0KDQojIEJyaWVmIFJhdGlvbmFsZSBvZiBteSBzdHVkeQ0KSW50ZXJwZXJzb25hbCB0cnVzdCBpcyBhbiBpbXBvcnRhbnQgZmFjZXQgb2YgcmVsYXRpb25zaGlwcywgYnV0IGN1cnJlbnQgdGhlb3JpZXMgYW5kIHJlc2VhcmNoIHBhcmFkaWdtcyBvbiBpbnRlcnBlcnNvbmFsIHRydXN0IG1heSBiZSBpbmNvbXBsZXRlLiBUcnVzdCBoYXMgdHJhZGl0aW9uYWxseSBiZWVuIHN0dWRpZWQgYXMgZWl0aGVyIGEgdHJhaXQgb2YgdGhlIGluZGl2aWR1YWwgb3IgYSBmYWNldCBvZiBhIHNwZWNpZmljIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHR3byBwZW9wbGUuIEFsdGhvdWdoIGJvdGggYXBwcm9hY2hlcyBoaWdobGlnaHQgZGlmZmVyZW50IGFuZCBpbXBvcnRhbnQgYXNwZWN0cyBvZiB0aGUgcHN5Y2hvbG9neSBvZiB0cnVzdCwgYm90aCBhcHByb2FjaGVzIGFyZSBsaW1pdGVkIGluIHRoZWlyIGFiaWxpdHkgdG8gdW5jb3ZlciBtb3JlIG1pbnV0ZSBkeW5hbWljcy4gDQoNCkluIG15IGRpc3NlcnRhdGlvbiwgSSBwcm9wb3NlZCBhbmQgdGVzdGVkIGEgZ29hbC1zcGVjaWZpYyB0aGVvcnkgb2YgaW50ZXJwZXJzb25hbCB0cnVzdCwgdGhlIEludGVyZGVwZW5kZW50IEdvYWwgTW9kZWwgb2YgSW50ZXJwZXJzb25hbCBUcnVzdCAoSUdNKS4gSSBhcmd1ZWQgdGhhdCB0aGUgdHJ1c3QgYmV0d2VlbiB0d28gcGVvcGxlIHZhcmllcyBhY3Jvc3MgdGhlIGludGVyZGVwZW5kZW50IGdvYWxzIHRoYXQgYXJlIHNoYXJlZCB3aXRoaW4gYSByZWxhdGlvbnNoaXAgYW5kIHRoYXQgdGhpcyB2YXJpYWJpbGl0eSBpcyBpbXBvcnRhbnQgZm9yIHVuZGVyc3RhbmRpbmcgaW50ZXJwZXJzb25hbCByZWxhdGlvbnNoaXBzLiANCg0KVGVzdGluZyB0aGUgaHlwb3RoZXNlcyBkZXJpdmVkIGZyb20gdGhlIElHTSByZXF1aXJlZCBhIG1ldGhvZG9sb2d5IHNlbnNpdGl2ZSB0byB0aGUgaWRpb3N5bmNyYXRpYyBnb2FscyBhbmQgcmVsYXRpb25zaGlwcyBvZiB0aGUgcGFydGljaXBhbnRzLiBUbyB0aGlzIGVuZCwgSSBlbXBsb3llZCBhIG5vdmVsIGFuZCBpZGVvZ3JhcGhpY2FsbHktdGFpbG9yZWQgc3VydmV5IGluIHdoaWNoIHBhcnRpY2lwYW50cyBkZXNjcmliZWQgdGhlaXIgY3VycmVudCBnb2FscyBhbmQgYmVzdCBmcmllbmQuIEFmdGVyIHBhcnRpY2lwYW50cyBkZXNjcmliZWQgdGhlaXIgZ29hbHMgYW5kIGJlc3QgZnJpZW5kLCB0aGV5IHdlcmUgYXNrZWQgdG8gd2hhdCBleHRlbnQgdGhleSB3b3VsZCB0cnVzdCB0aGVpciBiZXN0IGZyaWVuZCBhY3Jvc3Mgc29tZSBvZiB0aGVpciBtb3N0IGFuZCBsZWFzdCBpbXBvcnRhbnQgZ29hbHMuICANCg0KT24gdGhpcyBwYWdlLCBJIHdpbGwgd2FsayB5b3UgdGhyb3VnaCB0aGUgbG9naWMgYW5kIG1haW4gZmluZGluZ3Mgb2YgbXkgZGlzc2VydGF0aW9uLCBpbmNsdWRpbmcgYWxsIG5lY2Vzc2FyeSBkYXRhIHByZS1wcm9jZXNzaW5nIHN0ZXBzIGFuZCBteSBhbmFseXNlcy4gSWYgeW91J3JlIGludGVyZXN0ZWQgaW4gYSBtb3JlIGRldGFpbGVkIGFjY291bnQgb2YgbXkgdGhlb3J5LCBoeXBvdGhlc2VzLCBhbmQgbWV0aG9kcywgdGhlbiBJIGVuY291cmFnZSB5b3UgdG8gcmVhZCBteSBkaXNzZXJ0YXRpb24gW2hlcmVdKENhcnNlbF8yMDIwX0ludGVyZGVwZW5kZW50IGdvYWwgbW9kZWwgb2YgdHJ1c3QucGRmKQ0KPGJyLz48YnIvPjxici8+PGJyLz4NCg0KDQoNCg0KIyBIeXBvdGhlc2VzDQotIFRoZSBmaXJzdCBoeXBvdGhlc2lzIG9mIHRoZSBwcmVzZW50IHN0dWR5IGlzIHRoYXQgaW50ZXJwZXJzb25hbCB0cnVzdCB3aWxsIGluY3JlYXNlIGFzIHRoZSByZWxldmFuY2Ugb2YgYSBiZXN0IGZyaWVuZOKAmXMgc3RyZW5ndGggdG8gYSBnaXZlbiB0YXNrIGluY3JlYXNlcywgYW5kIGludGVycGVyc29uYWwgdHJ1c3Qgd2lsbCBkZWNyZWFzZSBhcyB0aGUgcmVsZXZhbmNlIG9mIGEgYmVzdCBmcmllbmTigJlzIHdlYWtuZXNzIHRvIGEgZ2l2ZW4gdGFzayBpbmNyZWFzZXMuIA0KDQotIFRoZSBzZWNvbmQgaHlwb3RoZXNpcyBvZiB0aGUgcHJlc2VudCBzdHVkeSBpcyB0aGF0IGluZGl2aWR1YWxzIHdpbGwgcGxhY2UgbG93ZXIgdHJ1c3QgaW4gYW5vdGhlciBwZXJzb24gb24gYXZlcmFnZSBhY3Jvc3MgYSByYW5nZSBvZiBoaWdobHkgaW1wb3J0YW50IGdvYWxzIHJlbGF0aXZlIHRvIGdvYWxzIG9mIGxvd2VyIGltcG9ydGFuY2UuDQoNCi0gVGhlIHRoaXJkIGh5cG90aGVzaXMgb2YgdGhlIHByZXNlbnQgc3R1ZHkgaXMgdGhhdCBmb3IgbW9yZSBpbXBvcnRhbnQgZ29hbHMsIHBlb3BsZSB3aWxsIGJlIG1vcmUgbGlrZWx5IHRvIHRydXN0IGFuIGltcG9ydGFudCByZWxhdGlvbmFsIHBhcnRuZXIgKGUuZy4sIGJlc3QgZnJpZW5kKSBpZiB0aGV5IGJlbGlldmUgdGhlIHRydXN0ZWXigJlzIHN0cmVuZ3RocyBhcmUgcmVsZXZhbnQgdG8gdGhlIHRhc2sgYW5kIGxlc3MgbGlrZWx5IHRvIHRydXN0IHRoYXQgcmVsYXRpb25hbCBwYXJ0bmVyIGlmIHRoZXkgYmVsaWV2ZSB0aGUgdHJ1c3RlZeKAmXMgd2Vha25lc3NlcyBhcmUgcmVsZXZhbnQgdG8gdGhlIHRhc2suIEZvciBnb2FscyB0aGF0IGFyZSBsZXNzIGltcG9ydGFudCwgYmVsaWVmcyBhYm91dCB0aGUgdHJ1c3RlZeKAmXMgc3RyZW5ndGhzIGFuZCB3ZWFrbmVzc2VzIHdpbGwgYmUgbGVzcyByZWxldmFudC4NCjxici8+PGJyLz48YnIvPjxici8+DQoNCg0KDQoNCiMgU3VydmV5IE1ldGhvZG9sb2d5IE92ZXJ2aWV3DQpJbiBvcmRlciB0byB1bmRlcnN0YW5kIGFueSBhbmFseXNpcywgaXQncyBpbXBvcnRhbnQgdG8gZmlyc3QgdW5kZXJzdGFuZCB0aGUgZGF0YSBnZW5lcmF0aW9uIHByb2Nlc3MuIEluIHRoZSBjYXNlIG9mIHRoZXNlIGRhdGEsIHBhcnRpY2lwYW50cyBjb21wbGV0ZWQgYW4gaWRpb2dyYXBoaWNhbGx5LXRhaWxvcmVkIHN1cnZleS4gDQoNCkEgdHJhZGl0aW9uYWwgc3VydmV5IHVzZXMgd2hhdCdzIGNhbGxlZCBhICoqbm9tb3RoZXRpYyoqIGFwcHJvYWNoLCB3aGljaCBhaW1zIHRvIHVuZGVyc3RhbmQgaG93IGdyb3VwcyBvZiBwZW9wbGUgYWN0LiBUaGVzZSBhcmUgdGhlIGtpbmRzIG9mIHN1cnZleXMgcGVvcGxlIHRha2UgYWxsIHRoZSB0aW1lLiBGb3IgZXhhbXBsZSwgaWYgeW91J3ZlIGV2ZXIgY29tcGxldGVkIGEgY3VzdG9tZXIgc2F0aXNmYWN0aW9uIHN1cnZleSB0aGF0IGFza2VkIHlvdSBxdWVzdGlvbnMgbGlrZSAiT24gYSBzY2FsZSBvZiAxIHRvIDUsIGhvdyBzYXRpc2ZpZWQgd2VyZSB5b3Ugd2l0aCB0aGUgc2VydmljZSB5b3UgcmVjZWl2ZWQ/IiwgdGhlbiB5b3UgaGF2ZSBjb21wbGV0ZWQgYSBub21vdGhldGljYWxseS1kZXNpZ25lZCBzdXJ2ZXkuIA0KDQpCeSBjb250cmFzdCwgYW4gKippZGlvZ3JhcGhpYyoqIGFwcHJvYWNoIGFpbXMgdG8gdW5kZXJzdGFuZCB0aGUgaWRpb3N5bmNyYWNpZXMgb2YgdGhlIGluZGl2aWR1YWwuIEFuIGV4YW1wbGUgb2YgYW4gaWRpb2dyYXBoaWNhbGx5LWRlc2lnbmVkIGN1c3RvbWVyIHNhdGlzZmFjdGlvbiBzdXJ2ZXkgcXVlc3Rpb24gbWlnaHQgYmUgc29tZXRoaW5nIG1vcmUgYWxvbmcgdGhlIGxpbmVzIG9mICJXaGF0IHdhcyB0aGUgbW9zdCBpbXBvcnRhbnQgcGFydCBvZiB0aGUgc2VydmljZSB5b3UgcmVjZWl2ZWQgZm9yIHdoeSB5b3UgZ2F2ZSB0aGUgcmF0aW5nIHlvdSBkaWQ/Iiwgd2l0aCBhbiBvcGVuLWVuZGVkIHRleHQgYm94IGZvciBwZW9wbGUgdG8gd3JpdGUgaW4gdGhlaXIgcmVzcG9uc2UuDQo8YnIvPjxici8+PGJyLz4NCg0KIyMgTWV0aG9kDQpJbiBpZGlvZ3JhcGhpY2FsbHktdGFpbG9yZWQgc3VydmV5IGZyb20gd2hpY2ggd2UgZ290IG91ciBkYXRhLCBwYXJ0aWNpcGFudHMgd2VyZSBhc2tlZCBhYm91dCB0aGVpciBnb2FscyBhbmQgdGhlaXIgYmVzdCBmcmllbmQuIFNwZWNpZmljYWxseSwgcGFydGljaXBhbnRzIGZpcnN0IGxpc3RlZCB0aGUgZ29hbHMgdGhleSB3ZXJlIGN1cnJlbnRseSBwdXJzdWluZywgYW5kIHRoZW4gdGhleSB3ZXJlIGFza2VkIHRvIHNlbGVjdCB0aGVpciB0aHJlZSBtb3N0IGFuZCB0aHJlZSBsZWFzdCBpbXBvcnRhbnQgZ29hbHMuIE5leHQsIHBhcnRpY2lwYW50cyB3ZXJlIGFza2VkIHRvIGlkZW50aWZ5IHRoZWlyIGJlc3QgZnJpZW5kIGFuZCB0aGVpciBiZXN0IGZyaWVuZCdzIG1vc3QgZGVzY3JpcHRpdmUgc3RyZW5ndGggYW5kIHdlYWtuZXNzLiBBZnRlcndhcmRzLCBwYXJ0aWNpcGFudHMgd2VyZSBhc2tlZCB0byB3aGF0IGV4dGVudCB0aGVpciBiZXN0IGZyaWVuZCdzIG1vc3QgZGVzY3JpcHRpdmUgc3RyZW5ndGggYW5kIHdlYWtuZXNzIHdlcmUgcmVsZXZhbnQgdG8gZWFjaCBvZiB0aGUgcGFydGljaXBhbnRzJyB0aHJlZSBtb3N0IGFuZCB0aHJlZSBsZWFzdCBpbXBvcnRhbnQgZ29hbHMuIEZpbmFsbHksIHBhcnRpY2lwYW50cyB3ZXJlIGFza2VkIHRvIHdoYXQgZXh0ZW50IHRoZXkgd291bGQgdHJ1c3QgdGhlaXIgYmVzdCBmcmllbmQgYWNyb3NzIHRoZWlyIHRocmVlIG1vc3QgYW5kIHRocmVlIGxlYXN0IGltcG9ydGFudCBnb2Fscy4gVGhlIGNyaXRlcmlvbiB2YXJpYWJsZSBvZiB0aGlzIHN0dWR5LCBvciB0aGUgdGhpbmcgd2Ugd2FudCB0byBwcmVkaWN0LCBpcyB0aGUgdHJ1c3QgcGFydGljaXBhbnRzIHBsYWNlZCBpbiB0aGVpciBiZXN0IGZyaWVuZCBhY3Jvc3MgdGhvc2Ugc2l4IGdvYWxzLg0KPGJyLz48YnIvPjxici8+PGJyLz4NCg0KDQoNCg0KIyBEYXRhIFByZS1wcm9jZXNzaW5nDQpUaGUgZmlyc3Qgc3RlcCBpbiBhbmFseXppbmcgZGF0YSBpbiBgYGBSYGBgIGlzIHRvIHNldCB5b3VyIHdvcmtpbmcgZW52aXJvbm1lbnQgYW5kIHRoZW4gbG9hZCB5b3VyIGRhdGEgYW5kIHJlcXVpcmVkIHBhY2thZ2VzLiBJIGhhdmUgYWxyZWFkeSBkb25lIHRoYXQgaW4gdGhlIGJhY2tncm91bmQsIHNvIEkgZW5jb3VyYWdlIHlvdSB0byBkb3dubG9hZCB0aGUgY29kZSBmb3IgdGhpcyBwYWdlIGlmIHlvdSB3b3VsZCBsaWtlIHRvIHNlZSB0aGF0IHN0ZXAuIEkgd2lsbCBvbmx5IHNob3cgb25lIGV4YW1wbGUgb2YgY29kZSBmb3IgZWFjaCBwcmUtcHJvY2Vzc2luZyBzdGVwIHRvIHNhdmUgcHJlY2lvdXMgaW50ZXJuZXQgc3BhY2UuDQoNCkFmdGVyIHlvdSd2ZSBzZXQgdXAgeW91ciBlbnZpb3JubWVudCB5b3UgY2FuIHN0YXJ0IHByZS1wcm9jZXNzaW5nIHlvdXIgZGF0YSB0byBnZXQgaXQgaW50byB0aGUgbmVjZXNzYXJ5IGZvcm1hdCBmb3IgYW5hbHlzZXMuIEJlbG93LCBJIGNyZWF0ZSBhIHBhcnRpY2lwYW50IGlkZW50aWZpY2F0aW9uIG51bWJlciAoUElOKSBhbmQgc2V0IGl0IGFzIGEgZmFjdG9yLiBUaGVuIEkgcmVuYW1lIHRoZSB2YXJpYWJsZXMgdGhhdCBpZGVudGlmeSBleGFjdGx5ICpob3cqIGltcG9ydGFudCwgb24gYSAxIHRvIDEwIHNjYWxlLCBwYXJ0aWNpcGFudHMgdmlld2VkIHRoZWlyIHRocmVlIG1vc3QgYW5kIHRocmVlIGxlYXN0IGltcG9ydGFudCBnb2Fscy4NCg0KYGBge3IsIHdhcm5pbmcgPSBGQUxTRX0NCiMgQ3JlYXRpbmcgYSBQSU4NCmRhdGExJFBJTjwtc2VxKGZyb209MSwgdG89bGVuZ3RoKGRhdGExJFByb2dyZXNzKSkNCiMgU2V0dGluZyB0aGUgdmFyaWFibGUgYXMgYSBmYWN0b3IgZm9yIGFuYWx5c2VzDQpkYXRhMSRQSU48LWFzLmZhY3RvcihkYXRhMSRQSU4pDQoNCg0KIyMgQ3JlYXRpbmcgdmFyaWFibGVzIGZvciB0aGUgY29udGludW91cyBtZWFzdXJlIG9mIGdvYWwgaW1wb3J0YW5jZSANCiMgTW9zdCBJbXBvcnRhbnQgR29hbHMgDQpkYXRhMSRnMUltcDwtKGFzLm51bWVyaWMoZGF0YTEkUTUuMiktMSkNCmBgYA0KDQpgYGB7ciwgd2FybmluZyA9IEZBTFNFLCBlY2hvID0gRkFMU0V9DQpkYXRhMSRnMkltcDwtKGFzLm51bWVyaWMoZGF0YTEkUTYuMiktMSkNCmRhdGExJGczSW1wPC0oYXMubnVtZXJpYyhkYXRhMSRRNy4yKS0xKQ0KIyBMZWFzdCBJbXBvcnRhbnQgR29hbHMNCmRhdGExJGc0SW1wPC0oYXMubnVtZXJpYyhkYXRhMSRROC4yKS0xKQ0KZGF0YTEkZzVJbXA8LShhcy5udW1lcmljKGRhdGExJFE5LjIpLTEpDQpkYXRhMSRnNkltcDwtKGFzLm51bWVyaWMoZGF0YTEkUTEwLjIpLTEpDQoNCmBgYA0KDQpOZXh0LCBJIGhhdmUgdG8gY3JlYXRlIHRoZSB2YXJpYWJsZXMgdGhhdCBpbmRpY2F0ZSB0byB3aGF0IGV4dGVudCBwYXJ0aWNpcGFudHMnIGJlc3QgZnJpZW5kJ3MgbW9zdCBkZXNjcmlwdGl2ZSBzdHJlbmd0aCBhbmQgd2Vha25lc3Mgd2VyZSB0byBlYWNoIG9mIHRoZSBzaXggZ29hbHMuIEhlcmUgaXMgd2hlcmUgd2UgY29tZSBhY3Jvc3Mgb3VyIGZpcnN0IGNvZGluZyBjaGFsbGVuZ2UuDQoNCkJlY2F1c2UgdGhpcyBzdXJ2ZXkgd2FzIGlkaW9ncmFwaGljYWxseS10YWlsb3JlZCwgYW5kIHBhcnRpY2lwYW50cyBjb3VsZCBoYXZlIGlkZW50aWZpZWQgYW55d2hlcmUgZnJvbSA2IHRvIDI1IGdvYWxzLCB0aGVzZSBkYXRhIGFyZSB3aGF0J3Mga25vd24gYXMgKipzcGFyc2UqKi4gU3BhcnNlIGRhdGEgaGFzIGEgbG90IG9mIGVtcHR5IGNlbGxzLCBhbmQgdGhpcyB3YXMgb25lIG9mIHRoZSBzcGFyc2VzdCBkYXRhIHNldHMgSSd2ZSBldmVyIHdvcmtlZCB3aXRoLiBJbiB0aGlzIGNhc2UsIHRoZXJlIHdhcyBhIHNpbmdsZSB2YWx1ZSBmb3IgZXZlcnkgcGFydGljaXBhbnQgc2NhdHRlcmVkIGFjcm9zcyAzMyBjb2x1bW5zISBJIG1lYW4sIHRha2UgYSBsb29rIGF0IHRoaXMgaG90IG1lc3MhDQoNCmBgYHtyfQ0KaGVhZChkYXRhMVssIDEzMTE6MTM0NV0pDQpgYGANCg0KSGVyZSBpcyB0aGUgY29kZSBJIHVzZWQgdG8gY29uZGVuc2UgdGhhdCBzcGFyc2UgZGF0YSBpbnRvIGEgc2V0IG9mIHZhcmlhYmxlcyBzbyB0aGF0IGV2ZXJ5IHBhcnRpY2lwYW50cycgdmFsdWUgd2FzIGluY2x1ZGVkIGluIGEgc2luZ2xlIHZhcmlhYmxlLg0KDQpgYGB7ciwgd2FybmluZyA9IEZBTFNFfQ0KIyMjIENyZWF0aW5nIEdvYWwgUmVsZXZhbmNlIFZhcmlhYmxlcyANCiMjIE1vc3QgSW1wb3J0YW50IEdvYWxzICMjIyMjIyMjIyMNCiMgR29hbCAxIFN0cmVuZ3RoDQpkYXRhMSRHb2FsMVN0clJlbDwtKGFwcGx5KGRhdGExWywgMTMxMToxMzQ1XSwgMSwgZnVuY3Rpb24oeCkgeFshaXMubmEoeCldWzFdKSktMQ0KYGBgDQoNCmBgYHtyLCB3YXJuaW5nID0gRkFMU0UsIGVjaG8gPSBGQUxTRX0NCiMgR29hbCAxIFdlYWtuZXNzDQpkYXRhMSRHb2FsMVdlYWtSZWw8LShhcHBseShkYXRhMVssIDEzNDY6MTM4MF0sIDEsIGZ1bmN0aW9uKHgpIHhbIWlzLm5hKHgpXVsxXSkpLTENCiMgR29hbCAyIFN0cmVuZ3RoDQpkYXRhMSRHb2FsMlN0clJlbDwtKGFwcGx5KGRhdGExWywgMTM4MToxNDE1XSwgMSwgZnVuY3Rpb24oeCkgeFshaXMubmEoeCldWzFdKSktMQ0KIyBHb2FsIDIgV2Vha25lc3MNCmRhdGExJEdvYWwyV2Vha1JlbDwtKGFwcGx5KGRhdGExWywgMTQxNjoxNDUwXSwgMSwgZnVuY3Rpb24oeCkgeFshaXMubmEoeCldWzFdKSktMQ0KIyBHb2FsIDMgU3RyZW5ndGgNCmRhdGExJEdvYWwzU3RyUmVsPC0oYXBwbHkoZGF0YTFbLCAxNDUxOjE0ODVdLCAxLCBmdW5jdGlvbih4KSB4WyFpcy5uYSh4KV1bMV0pKS0xDQojIEdvYWwgMyBXZWFrbmVzcw0KZGF0YTEkR29hbDNXZWFrUmVsPC0oYXBwbHkoZGF0YTFbLCAxNDg2OjE1MjBdLCAxLCBmdW5jdGlvbih4KSB4WyFpcy5uYSh4KV1bMV0pKS0xDQojIyBMZWFzdCBJbXBvcnRhbnQgR29hbHMNCiMgR29hbCA0IFN0cmVuZ3RoDQpkYXRhMSRHb2FsNFN0clJlbDwtKGFwcGx5KGRhdGExWywgMTUyMToxNTU1XSwgMSwgZnVuY3Rpb24oeCkgeFshaXMubmEoeCldWzFdKSktMQ0KIyBHb2FsIDQgV2Vha25lc3MNCmRhdGExJEdvYWw0V2Vha1JlbDwtKGFwcGx5KGRhdGExWywgMTU1NjoxNTkwXSwgMSwgZnVuY3Rpb24oeCkgeFshaXMubmEoeCldWzFdKSktMQ0KIyBHb2FsIDUgU3RyZW5ndGgNCmRhdGExJEdvYWw1U3RyUmVsPC0oYXBwbHkoZGF0YTFbLCAxNTkxOjE2MjVdLCAxLCBmdW5jdGlvbih4KSB4WyFpcy5uYSh4KV1bMV0pKS0xDQojIEdvYWwgNSBXZWFrbmVzcw0KZGF0YTEkR29hbDVXZWFrUmVsPC0oYXBwbHkoZGF0YTFbLCAxNjI2OjE2NjBdLCAxLCBmdW5jdGlvbih4KSB4WyFpcy5uYSh4KV1bMV0pKS0xDQojIEdvYWwgNiBTdHJlbmd0aA0KZGF0YTEkR29hbDZTdHJSZWw8LShhcHBseShkYXRhMVssIDE2NjE6MTY5NV0sIDEsIGZ1bmN0aW9uKHgpIHhbIWlzLm5hKHgpXVsxXSkpLTENCiMgR29hbCA2IFdlYWtuZXNzDQpkYXRhMSRHb2FsNldlYWtSZWw8LShhcHBseShkYXRhMVssIDE2OTY6MTczMF0sIDEsIGZ1bmN0aW9uKHgpIHhbIWlzLm5hKHgpXVsxXSkpLTENCmBgYA0KDQpMZXQncyBzZWUgaWYgdGhhdCB3b3JrZWQuDQoNCmBgYHtyfQ0KaGVhZChkYXRhMSRHb2FsMVN0clJlbDpkYXRhMSRHb2FsNlN0clJlbCkNCmBgYA0KDQpHcmVhdCEgTm93IHdlIGhhdmUgY29uZGVuc2VkIG91ciBmaXJzdCBzZXQgb2YgcHJlZGljdG9ycywgYW5kIGl0J3MgdGltZSB0byBtb3ZlIG9udG8gdGhlIG5leHQgc2V0IG9mIHZhcmlhYmxlcy4NCg0KVGhlIHZhcmlhYmxlcyB0aGF0IGNvbnRhaW5lZCBwYXJ0aWNpcGFudHMnIHRydXN0IGluIHRoZWlyIGJlc3QgZnJpZW5kIGFjcm9zcyBlYWNoIGdvYWwgd2FzIHNpbWlsYXJseSBzcGFyc2UsIHNvIEkgc2ltcGx5IGFwcGxpZWQgdGhlIHNhbWUgY29kZSB0byBmaXggdGhhdCBoZXJlLiBIb3dldmVyLCB0aGUgbWVhc3VyZXMgZm9yIGdvYWwtc3BlY2lmaWMgdHJ1c3Qgd2VyZSBhIGJpdCBtb3JlIGNvbXBsaWNhdGVkLCBzbyB0aGV5IHJlcXVpcmUgbW9yZSBjb2RlLiBTcGVjaWZpY2FsbHksIHBhcnRpY2lwYW50cyB3ZXJlIGZpcnN0IGFza2VkIGlmIHRoZXkgdHJ1c3RlZCB0aGVpciBiZXN0IGZyaWVuZCBvciBub3QgZm9yIGVhY2ggZ29hbCwgYW5kIHRoZW4gdGhleSB3ZXJlIGFza2VkIHRvIHdoYXQgZXh0ZW50IHRoZXkgdHJ1c3RlZCBvciBkaXN0cnVzdGVkIHRoZWlyIGJlc3QgZnJpZW5kLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGV5IGZpcnN0IHNlbGN0ZWQgdHJ1c3Qgb3IgZGlzdHJ1c3QuIEJlY2F1c2Ugd2Ugd2FzIGEgY29udGludW91cyBtZWFzdXJlIGZvciBvdXIgYW5hbHlzZXMsIHdlIG5lZWQgdG8gc29tZWhvdyBjb21iaW5lIHRob3NlIGV4dGVudCB2YXJpYWJsZXMgd2l0aCB0aGUgZGljaG90b21vdXMgbWVhc3VyZS4gQmVsb3cgaXMgdGhlIGNvZGUgZm9yIGhvdyBJIGFjY29tcGxpc2hlZCB0aGF0LiANCg0KYGBge3IsIHdhcm5pbmcgPSBGQUxTRX0NCiMjIyBDcmVhdGluZyBHb2FsLUJhc2VkIFRydXN0IERWcyAjIyMNCiMjIFRydXN0IGZvciBQcm9qZWN0IDEgDQojIFRydXN0DQpkYXRhMSRHb2FsMVRydXN0RGk8LShhcHBseShkYXRhMVssIDE3MzE6MTc2NV0sIDEsIGZ1bmN0aW9uKHgpIHhbIWlzLm5hKHgpXVsxXSkpDQojIEV4dGVudCBTcyBUcnVzdHMgQmVzdCBGcmllbmQgZm9yIFByb2plY3QgMQ0KZGF0YTEkRzFUcnVzdEV4dDwtYXMubnVtZXJpYyhkYXRhMSRRMjYuMikNCiMgRXh0ZW50IFNzIGRpc3RydXN0cyBCZXN0IEZyaWVuZCBmb3IgUHJvamVjdCAxDQpkYXRhMSRHMURpc3RydXN0RXh0PC1hcy5udW1lcmljKC1kYXRhMSRRMjYuMykNCiMgTGVhbiBUb3dhcmQgVHJ1c3QgdnMgRGlzdHJ1c3QNCmRhdGExJEcxVHJ1c3RMZWFuPC1hcy5udW1lcmljKGRhdGExJFEyNi40KQ0KIyBDcmVhdGluZyBiaXBvbGFyIG1lYXN1cmUgb2YgVHJ1c3QtRGlzdHJ1c3QNCmRhdGExJEdvYWwxVHJ1c3RCUDwtaWZlbHNlKGRhdGExJEdvYWwxVHJ1c3REaT09MSxkYXRhMSRHMVRydXN0RXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEdvYWwxVHJ1c3REaT09MixkYXRhMSRHMURpc3RydXN0RXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEcxVHJ1c3RMZWFuPT0xLDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkRzFUcnVzdExlYW49PTIsLTEsTkEpKSkpDQoNCiMgUmVseQ0KZGF0YTEkR29hbDFSZWx5RGk8LShhcHBseShkYXRhMVssIDE3Njk6MTgwM10sIDEsIGZ1bmN0aW9uKHgpIHhbIWlzLm5hKHgpXVsxXSkpDQojIEV4dGVudCBTcyBUcnVzdHMgQmVzdCBGcmllbmQgZm9yIFByb2plY3QgMQ0KZGF0YTEkRzFSZWx5RXh0PC1hcy5udW1lcmljKGRhdGExJFEyNi42KQ0KIyBFeHRlbnQgU3MgZGlzdHJ1c3RzIEJlc3QgRnJpZW5kIGZvciBQcm9qZWN0IDENCmRhdGExJEcxVW5yZWx5RGlFeHQ8LWFzLm51bWVyaWMoLWRhdGExJFEyNi43KQ0KIyBMZWFuIFRvd2FyZCBUcnVzdCB2cyBEaXN0cnVzdA0KZGF0YTEkRzFSZWx5TGVhbjwtYXMubnVtZXJpYyhkYXRhMSRRMjYuOCkNCiMgQ3JlYXRpbmcgYmlwb2xhciBtZWFzdXJlIG9mIFRydXN0LURpc3RydXN0DQpkYXRhMSRHb2FsMVJlbHlCUDwtaWZlbHNlKGRhdGExJEdvYWwxUmVseURpPT0xLGRhdGExJEcxUmVseUV4dCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHb2FsMVJlbHlEaT09MixkYXRhMSRHMVVucmVseURpRXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEcxUmVseUxlYW49PTEsMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHMVJlbHlMZWFuPT0yLC0xLE5BKSkpKQ0KYGBgDQoNCmBgYHtyLCB3YXJuaW5nID0gRkFMU0UsIGVjaG8gPSBGQUxTRX0NCiMjIFRydXN0IGZvciBQcm9qZWN0IDIgDQojIFRydXN0DQpkYXRhMSRHb2FsMlRydXN0RGk8LShhcHBseShkYXRhMVssIDE4MDc6MTg0MV0sIDEsIGZ1bmN0aW9uKHgpIHhbIWlzLm5hKHgpXVsxXSkpDQojIEV4dGVudCBTcyBUcnVzdHMgQmVzdCBGcmllbmQgZm9yIFByb2plY3QgMQ0KZGF0YTEkRzJUcnVzdEV4dDwtYXMubnVtZXJpYyhkYXRhMSRRMjcuMikNCiMgRXh0ZW50IFNzIGRpc3RydXN0cyBCZXN0IEZyaWVuZCBmb3IgUHJvamVjdCAxDQpkYXRhMSRHMkRpc3RydXN0RXh0PC1hcy5udW1lcmljKC1kYXRhMSRRMjcuMykNCiMgTGVhbiBUb3dhcmQgVHJ1c3QgdnMgRGlzdHJ1c3QNCmRhdGExJEcyVHJ1c3RMZWFuPC1hcy5udW1lcmljKGRhdGExJFEyNy40KQ0KIyBDcmVhdGluZyBiaXBvbGFyIG1lYXN1cmUgb2YgVHJ1c3QtRGlzdHJ1c3QNCmRhdGExJEdvYWwyVHJ1c3RCUDwtaWZlbHNlKGRhdGExJEdvYWwyVHJ1c3REaT09MSxkYXRhMSRHMlRydXN0RXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEdvYWwyVHJ1c3REaT09MixkYXRhMSRHMkRpc3RydXN0RXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEcyVHJ1c3RMZWFuPT0xLDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkRzJUcnVzdExlYW49PTIsLTEsTkEpKSkpDQoNCiMgUmVseQ0KZGF0YTEkR29hbDJSZWx5RGk8LShhcHBseShkYXRhMVssIDE4NDU6MTg3OV0sIDEsIGZ1bmN0aW9uKHgpIHhbIWlzLm5hKHgpXVsxXSkpDQojIEV4dGVudCBTcyBUcnVzdHMgQmVzdCBGcmllbmQgZm9yIFByb2plY3QgMQ0KZGF0YTEkRzJSZWx5RXh0PC1hcy5udW1lcmljKGRhdGExJFEyNy42KQ0KIyBFeHRlbnQgU3MgZGlzdHJ1c3RzIEJlc3QgRnJpZW5kIGZvciBQcm9qZWN0IDENCmRhdGExJEcyVW5yZWx5RGlFeHQ8LWFzLm51bWVyaWMoLWRhdGExJFEyNy43KQ0KIyBMZWFuIFRvd2FyZCBUcnVzdCB2cyBEaXN0cnVzdA0KZGF0YTEkRzJSZWx5TGVhbjwtYXMubnVtZXJpYyhkYXRhMSRRMjcuOCkNCiMgQ3JlYXRpbmcgYmlwb2xhciBtZWFzdXJlIG9mIFRydXN0LURpc3RydXN0DQpkYXRhMSRHb2FsMlJlbHlCUDwtaWZlbHNlKGRhdGExJEdvYWwyUmVseURpPT0xLGRhdGExJEcyUmVseUV4dCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEdvYWwyUmVseURpPT0yLGRhdGExJEcyVW5yZWx5RGlFeHQsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHMlJlbHlMZWFuPT0xLDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHMlJlbHlMZWFuPT0yLC0xLE5BKSkpKQ0KDQojIyBUcnVzdCBmb3IgUHJvamVjdCAzIA0KIyBUcnVzdA0KZGF0YTEkR29hbDNUcnVzdERpPC0oYXBwbHkoZGF0YTFbLCAxODgzOjE5MTddLCAxLCBmdW5jdGlvbih4KSB4WyFpcy5uYSh4KV1bMV0pKQ0KIyBFeHRlbnQgU3MgVHJ1c3RzIEJlc3QgRnJpZW5kIGZvciBQcm9qZWN0IDENCmRhdGExJEczVHJ1c3RFeHQ8LWFzLm51bWVyaWMoZGF0YTEkUTI4LjIpDQojIEV4dGVudCBTcyBkaXN0cnVzdHMgQmVzdCBGcmllbmQgZm9yIFByb2plY3QgMQ0KZGF0YTEkRzNEaXN0cnVzdEV4dDwtYXMubnVtZXJpYygtZGF0YTEkUTI4LjMpDQojIExlYW4gVG93YXJkIFRydXN0IHZzIERpc3RydXN0DQpkYXRhMSRHM1RydXN0TGVhbjwtYXMubnVtZXJpYyhkYXRhMSRRMjguNCkNCiMgQ3JlYXRpbmcgYmlwb2xhciBtZWFzdXJlIG9mIFRydXN0LURpc3RydXN0DQpkYXRhMSRHb2FsM1RydXN0QlA8LWlmZWxzZShkYXRhMSRHb2FsM1RydXN0RGk9PTEsZGF0YTEkRzNUcnVzdEV4dCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHb2FsM1RydXN0RGk9PTIsZGF0YTEkRzNEaXN0cnVzdEV4dCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHM1RydXN0TGVhbj09MSwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEczVHJ1c3RMZWFuPT0yLC0xLE5BKSkpKQ0KDQojIFJlbHkNCmRhdGExJEdvYWwzUmVseURpPC0oYXBwbHkoZGF0YTFbLCAxOTIxOjE5NTVdLCAxLCBmdW5jdGlvbih4KSB4WyFpcy5uYSh4KV1bMV0pKQ0KIyBFeHRlbnQgU3MgVHJ1c3RzIEJlc3QgRnJpZW5kIGZvciBQcm9qZWN0IDENCmRhdGExJEczUmVseUV4dDwtYXMubnVtZXJpYyhkYXRhMSRRMjguNikNCiMgRXh0ZW50IFNzIGRpc3RydXN0cyBCZXN0IEZyaWVuZCBmb3IgUHJvamVjdCAxDQpkYXRhMSRHM1VucmVseURpRXh0PC1hcy5udW1lcmljKC1kYXRhMSRRMjguNykNCiMgTGVhbiBUb3dhcmQgVHJ1c3QgdnMgRGlzdHJ1c3QNCmRhdGExJEczUmVseUxlYW48LWFzLm51bWVyaWMoZGF0YTEkUTI4LjgpDQojIENyZWF0aW5nIGJpcG9sYXIgbWVhc3VyZSBvZiBUcnVzdC1EaXN0cnVzdA0KZGF0YTEkR29hbDNSZWx5QlA8LWlmZWxzZShkYXRhMSRHb2FsM1JlbHlEaT09MSxkYXRhMSRHM1JlbHlFeHQsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHb2FsM1JlbHlEaT09MixkYXRhMSRHM1VucmVseURpRXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkRzNSZWx5TGVhbj09MSwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkRzNSZWx5TGVhbj09MiwtMSxOQSkpKSkNCg0KIyMgVHJ1c3QgZm9yIFByb2plY3QgNCANCiMgVHJ1c3QNCmRhdGExJEdvYWw0VHJ1c3REaTwtKGFwcGx5KGRhdGExWywgMTk1OToxOTkzXSwgMSwgZnVuY3Rpb24oeCkgeFshaXMubmEoeCldWzFdKSkNCiMgRXh0ZW50IFNzIFRydXN0cyBCZXN0IEZyaWVuZCBmb3IgUHJvamVjdCAxDQpkYXRhMSRHNFRydXN0RXh0PC1hcy5udW1lcmljKGRhdGExJFEyOS4yKQ0KIyBFeHRlbnQgU3MgZGlzdHJ1c3RzIEJlc3QgRnJpZW5kIGZvciBQcm9qZWN0IDENCmRhdGExJEc0RGlzdHJ1c3RFeHQ8LWFzLm51bWVyaWMoLWRhdGExJFEyOS4zKQ0KIyBMZWFuIFRvd2FyZCBUcnVzdCB2cyBEaXN0cnVzdA0KZGF0YTEkRzRUcnVzdExlYW48LWFzLm51bWVyaWMoZGF0YTEkUTI5LjQpDQojIENyZWF0aW5nIGJpcG9sYXIgbWVhc3VyZSBvZiBUcnVzdC1EaXN0cnVzdA0KZGF0YTEkR29hbDRUcnVzdEJQPC1pZmVsc2UoZGF0YTEkR29hbDRUcnVzdERpPT0xLGRhdGExJEc0VHJ1c3RFeHQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkR29hbDRUcnVzdERpPT0yLGRhdGExJEc0RGlzdHJ1c3RFeHQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkRzRUcnVzdExlYW49PTEsMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHNFRydXN0TGVhbj09MiwtMSxOQSkpKSkNCg0KIyBSZWx5DQpkYXRhMSRHb2FsNFJlbHlEaTwtKGFwcGx5KGRhdGExWywgMTk5NzoyMDMxXSwgMSwgZnVuY3Rpb24oeCkgeFshaXMubmEoeCldWzFdKSkNCiMgRXh0ZW50IFNzIFRydXN0cyBCZXN0IEZyaWVuZCBmb3IgUHJvamVjdCAxDQpkYXRhMSRHNFJlbHlFeHQ8LWFzLm51bWVyaWMoZGF0YTEkUTI5LjYpDQojIEV4dGVudCBTcyBkaXN0cnVzdHMgQmVzdCBGcmllbmQgZm9yIFByb2plY3QgMQ0KZGF0YTEkRzRVbnJlbHlEaUV4dDwtYXMubnVtZXJpYygtZGF0YTEkUTI5LjcpDQojIExlYW4gVG93YXJkIFRydXN0IHZzIERpc3RydXN0DQpkYXRhMSRHNFJlbHlMZWFuPC1hcy5udW1lcmljKGRhdGExJFEyOS44KQ0KIyBDcmVhdGluZyBiaXBvbGFyIG1lYXN1cmUgb2YgVHJ1c3QtRGlzdHJ1c3QNCmRhdGExJEdvYWw0UmVseUJQPC1pZmVsc2UoZGF0YTEkR29hbDRSZWx5RGk9PTEsZGF0YTEkRzRSZWx5RXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkR29hbDRSZWx5RGk9PTIsZGF0YTEkRzRVbnJlbHlEaUV4dCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEc0UmVseUxlYW49PTEsMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEc0UmVseUxlYW49PTIsLTEsTkEpKSkpDQoNCiMjIFRydXN0IGZvciBQcm9qZWN0IDUgDQojIFRydXN0DQpkYXRhMSRHb2FsNVRydXN0RGk8LShhcHBseShkYXRhMVssIDIwMzU6MjA2OV0sIDEsIGZ1bmN0aW9uKHgpIHhbIWlzLm5hKHgpXVsxXSkpDQojIEV4dGVudCBTcyBUcnVzdHMgQmVzdCBGcmllbmQgZm9yIFByb2plY3QgMQ0KZGF0YTEkRzVUcnVzdEV4dDwtYXMubnVtZXJpYyhkYXRhMSRRMzAuMikNCiMgRXh0ZW50IFNzIGRpc3RydXN0cyBCZXN0IEZyaWVuZCBmb3IgUHJvamVjdCAxDQpkYXRhMSRHNURpc3RydXN0RXh0PC1hcy5udW1lcmljKC1kYXRhMSRRMzAuMykNCiMgTGVhbiBUb3dhcmQgVHJ1c3QgdnMgRGlzdHJ1c3QNCmRhdGExJEc1VHJ1c3RMZWFuPC1hcy5udW1lcmljKGRhdGExJFEzMC40KQ0KIyBDcmVhdGluZyBiaXBvbGFyIG1lYXN1cmUgb2YgVHJ1c3QtRGlzdHJ1c3QNCmRhdGExJEdvYWw1VHJ1c3RCUDwtaWZlbHNlKGRhdGExJEdvYWw1VHJ1c3REaT09MSxkYXRhMSRHNVRydXN0RXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEdvYWw1VHJ1c3REaT09MixkYXRhMSRHNURpc3RydXN0RXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEc1VHJ1c3RMZWFuPT0xLDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkRzVUcnVzdExlYW49PTIsLTEsTkEpKSkpDQoNCiMgUmVseQ0KZGF0YTEkR29hbDVSZWx5RGk8LShhcHBseShkYXRhMVssIDIwNzM6MjEwN10sIDEsIGZ1bmN0aW9uKHgpIHhbIWlzLm5hKHgpXVsxXSkpDQojIEV4dGVudCBTcyBUcnVzdHMgQmVzdCBGcmllbmQgZm9yIFByb2plY3QgMQ0KZGF0YTEkRzVSZWx5RXh0PC1hcy5udW1lcmljKGRhdGExJFEzMC42KQ0KIyBFeHRlbnQgU3MgZGlzdHJ1c3RzIEJlc3QgRnJpZW5kIGZvciBQcm9qZWN0IDENCmRhdGExJEc1VW5yZWx5RGlFeHQ8LWFzLm51bWVyaWMoLWRhdGExJFEzMC43KQ0KIyBMZWFuIFRvd2FyZCBUcnVzdCB2cyBEaXN0cnVzdA0KZGF0YTEkRzVSZWx5TGVhbjwtYXMubnVtZXJpYyhkYXRhMSRRMzAuOCkNCiMgQ3JlYXRpbmcgYmlwb2xhciBtZWFzdXJlIG9mIFRydXN0LURpc3RydXN0DQpkYXRhMSRHb2FsNVJlbHlCUDwtaWZlbHNlKGRhdGExJEdvYWw1UmVseURpPT0xLGRhdGExJEc1UmVseUV4dCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEdvYWw1UmVseURpPT0yLGRhdGExJEc1VW5yZWx5RGlFeHQsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHNVJlbHlMZWFuPT0xLDEsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHNVJlbHlMZWFuPT0yLC0xLE5BKSkpKQ0KDQojIyBUcnVzdCBmb3IgUHJvamVjdCA2IA0KIyBUcnVzdA0KZGF0YTEkR29hbDZUcnVzdERpPC0oYXBwbHkoZGF0YTFbLCAyMTExOjIxNDVdLCAxLCBmdW5jdGlvbih4KSB4WyFpcy5uYSh4KV1bMV0pKQ0KIyBFeHRlbnQgU3MgVHJ1c3RzIEJlc3QgRnJpZW5kIGZvciBQcm9qZWN0IDENCmRhdGExJEc2VHJ1c3RFeHQ8LWFzLm51bWVyaWMoZGF0YTEkUTMxLjIpDQojIEV4dGVudCBTcyBkaXN0cnVzdHMgQmVzdCBGcmllbmQgZm9yIFByb2plY3QgMQ0KZGF0YTEkRzZEaXN0cnVzdEV4dDwtYXMubnVtZXJpYygtZGF0YTEkUTMxLjMpDQojIExlYW4gVG93YXJkIFRydXN0IHZzIERpc3RydXN0DQpkYXRhMSRHNlRydXN0TGVhbjwtYXMubnVtZXJpYyhkYXRhMSRRMzEuNCkNCiMgQ3JlYXRpbmcgYmlwb2xhciBtZWFzdXJlIG9mIFRydXN0LURpc3RydXN0DQpkYXRhMSRHb2FsNlRydXN0QlA8LWlmZWxzZShkYXRhMSRHb2FsNlRydXN0RGk9PTEsZGF0YTEkRzZUcnVzdEV4dCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHb2FsNlRydXN0RGk9PTIsZGF0YTEkRzZEaXN0cnVzdEV4dCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHNlRydXN0TGVhbj09MSwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZlbHNlKGRhdGExJEc2VHJ1c3RMZWFuPT0yLC0xLE5BKSkpKQ0KDQojIFJlbHkNCmRhdGExJEdvYWw2UmVseURpPC0oYXBwbHkoZGF0YTFbLCAyMTQ5OjIxODNdLCAxLCBmdW5jdGlvbih4KSB4WyFpcy5uYSh4KV1bMV0pKQ0KIyBFeHRlbnQgU3MgVHJ1c3RzIEJlc3QgRnJpZW5kIGZvciBQcm9qZWN0IDENCmRhdGExJEc2UmVseUV4dDwtYXMubnVtZXJpYyhkYXRhMSRRMzEuNikNCiMgRXh0ZW50IFNzIGRpc3RydXN0cyBCZXN0IEZyaWVuZCBmb3IgUHJvamVjdCAxDQpkYXRhMSRHNlVucmVseURpRXh0PC1hcy5udW1lcmljKC1kYXRhMSRRMzEuNykNCiMgTGVhbiBUb3dhcmQgVHJ1c3QgdnMgRGlzdHJ1c3QNCmRhdGExJEc2UmVseUxlYW48LWFzLm51bWVyaWMoZGF0YTEkUTMxLjgpDQojIENyZWF0aW5nIGJpcG9sYXIgbWVhc3VyZSBvZiBUcnVzdC1EaXN0cnVzdA0KZGF0YTEkR29hbDZSZWx5QlA8LWlmZWxzZShkYXRhMSRHb2FsNlJlbHlEaT09MSxkYXRhMSRHNlJlbHlFeHQsDQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmZWxzZShkYXRhMSRHb2FsNlJlbHlEaT09MixkYXRhMSRHNlVucmVseURpRXh0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkRzZSZWx5TGVhbj09MSwxLA0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZmVsc2UoZGF0YTEkRzZSZWx5TGVhbj09MiwtMSxOQSkpKSkNCmBgYA0KDQpXaGV3ISEgVGhhdCdzIGEgbG90ISBCdXQgd2UncmUgYWxtb3N0IGRvbmUuIFdlIGhhdmUgY3JlYXRlZCBvdXIgUElOLCB0aGUgY29udGludW91cyBtZWFzdXJlIG9mIGdvYWwgbXBvcnRhbmNlIChmb3IgYSBtYW5pcHVsYXRpb24gY2hlY2spLCB0aGUgcmVsZXZhbmNlIG9mIHRoZSBiZXN0IGZyaWVuZCdzIG1vc3QgZGVzY3JpcHRpdmUgc3RyZW5ndGggYW5kIHdlYWtuZXNzIHRvIGVhY2ggZ29hbCwgYW5kIHRoZSBtZWFzdXJlIG9mIGdvYWwtc3BlY2lmaWMgdHJ1c3QuIEFsbCB0aGF0IGlzIGxlZnQgaXMgdG8gY3JlYXRlIGEgc3Vic2V0IG9mIHRoZSBkYXRhIHdpdGggb25seSB0aGUgdmFyaWFibGVzIHRoYXQgd2UgbmVlZCBhbmQgdG8gcHV0IGl0IGludG8gdGhlIHByb3BlciBmb3JtYXQuDQoNCkhlcmUsIEkgc3Vic2V0IHRoZSBkYXRhIGFuZCBjcmVhdGUgdGhlIGRhdGFmcmFtbWUgdGhhdCBJJ2xsIHVzZSBmb3IgcGxvdHRpbmcgYW5kIG15IGFuYWx5c2VzDQoNCmBgYHtyLCB3YXJuaW5nID0gRkFMU0V9DQpkYXRhMjwtc3Vic2V0KGRhdGExLHNlbGVjdD1jKFBJTjpHb2FsMVRydXN0RGksR29hbDFUcnVzdEJQLEdvYWwxUmVseURpLEdvYWwxUmVseUJQLEdvYWwyVHJ1c3REaSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR29hbDJUcnVzdEJQLEdvYWwyUmVseURpLEdvYWwyUmVseUJQLEdvYWwzVHJ1c3REaSxHb2FsM1RydXN0QlAsR29hbDNSZWx5RGksDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdvYWwzUmVseUJQLEdvYWw0VHJ1c3REaSxHb2FsNFRydXN0QlAsR29hbDRSZWx5RGksR29hbDRSZWx5QlAsR29hbDVUcnVzdERpLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHb2FsNVRydXN0QlAsR29hbDVSZWx5RGksR29hbDVSZWx5QlAsR29hbDZUcnVzdERpLEdvYWw2VHJ1c3RCUCxHb2FsNlJlbHlEaSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR29hbDZSZWx5QlApKSANCmBgYA0KDQpMZXQncyBjaGVjayBpdCB0byBtYWtlIHN1cmUgZXZlcnl0aGluZyB3b3JrZWQgcHJvcGVybHkNCg0KYGBge3IsIHdhcm5pbmcgPSBGQUxTRX0NCnN0cihkYXRhMikNCmBgYA0KDQpQZXJmZWN0ISBOb3csIGxldCdzIGFycmFuZ2UgdGhlIHZhcmlhYmxlcyBmb3IgZWFzaWVyIG1hbmlwdWxhdGlvbiBhbmQgc2V0IGJldHRlciBuYW1lcy4gSW4gb3JkZXIgdG8gZG8gdGhpcywgd2UnbGwgbmVlZCB0byBjb252ZXJ0IG91ciBkYXRhIGZyb20gKip3aWRlIGZvcm1hdCoqIHRvICoqbG9uZyBmb3JtYXQqKi4NCg0KTW9zdCBwZW9wbGUgYXJlIHByb2JhYmx5IG1vcmUgZmFtaWxpYXIgd2l0aCAqKndpZGUgZm9ybWF0KiouIEluICoqd2lkZSBmb3JtYXQqKiwgZXZlcnkgY29sdW1uIGlzIGEgdmFyaWFibGUsIGFuZCBldmVyeSByb3cgaXMgYSBjYXNlIG9yIGluc3RhbmNlIG9mIHRoZSB2YXJpYWJsZSAicGFydGljaXBhbnQuIiBJbiBvdGhlciB3b3JkcywgZWFjaCBjYXNlIHJlcHJlc2VudHMgYSBzaW5nbGUgcGFydGljaXBhbnQuIEluICoqbG9uZyBmb3JtYXQqKiwgd2Ugc3RyZXRjaCBvdXQgb3VyIGRhdGEgc28gdGhhdCBlYWNoIHBhcnRpY2lwYW50IG9jY3VwaWVzIG11bHRpbXBsZSByb3dzLiBJbiB0aGUgZW5kIG9mIHRoaXMgdHJhbnNmb3JtYXRpb24sIGVhY2ggcm93IHdpbGwgYmUgYW4gaW5zdGFuY2Ugb3IgY2FzZSBvZiB0aGUgdmFyaWFibGUgImdvYWwiIHNvIHRoYXQgZXZlcnkgcGFydGljaXBhbnQgd2lsbCBvY2N1cHkgKio2Kiogcm93cywgb25lIGZvciBlYWNoIG9mIHRoZWlyIHRocmVlIG1vc3QgYW5kIHRocmVlIGxlYXN0IGltcG9ydGFudCBnb2Fscy4NCg0KYGBge3IsIHdhcm5pbmcgPSBGQUxTRX0NCiMjIyBBcnJhbmdpbmcgY29sdW1ucyBmb3IgZWFzaWVyIG1hbmlwdWxhdGlvbiANCiMjIEdvYWwgSW1wb3J0YW5jZSANCiMgU2VsZWN0IHZhcnMNCmltcERhdGE8LWRhdGEyICU+JSBkcGx5cjo6c2VsZWN0KHRpZHlzZWxlY3Q6OnZhcnNfc2VsZWN0KG5hbWVzKGRhdGEyKSwgZHBseXI6Om1hdGNoZXMoJ0ltcCcpKSkNCiMgQWRkIFBJTg0KaW1wRGF0YSRQSU48LWRhdGEyJFBJTg0KIyBXaWRlIHRvIExvbmcNCmltcExvbmc8LWltcERhdGEgJT4lIGdhdGhlcihHb2FsLEltcG9ydGFuY2UsZzFJbXA6ZzZJbXApDQojIFJlbmFtZSBmYWN0b3IgbGV2ZWxzDQppbXBMb25nJEdvYWw8LW1hcHZhbHVlcyhpbXBMb25nJEdvYWwsIGZyb20gPSBjKCJnMUltcCIsImcySW1wIiwiZzNJbXAiLCJnNEltcCIsImc1SW1wIiwiZzZJbXAiKSwNCiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gYygiR29hbDEiLCJHb2FsMiIsIkdvYWwzIiwiR29hbDQiLCJHb2FsNSIsIkdvYWw2IikpDQoNCiMjIFJlbGV2YW5jZSBvZiBzdHJlbmd0aCB0byBlYWNoIHByb2plY3QgDQojIFNlbGVjdCB2YXJzDQpzdHJlbmd0aERhdGE8LWRhdGEyICU+JSBkcGx5cjo6c2VsZWN0KHRpZHlzZWxlY3Q6OnZhcnNfc2VsZWN0KG5hbWVzKGRhdGEyKSwgbWF0Y2hlcygnU3RyUmVsJykpKQ0KIyBBZGQgUElODQpzdHJlbmd0aERhdGEkUElOPC1kYXRhMiRQSU4NCiMgV2lkZSB0byBMb25nDQpzcmVsTG9uZzwtc3RyZW5ndGhEYXRhICU+JSBnYXRoZXIoR29hbCxTdFJlbCxHb2FsMVN0clJlbDpHb2FsNlN0clJlbCkNCiMgUmVuYW1lIGZhY3RvciBsZXZlbHMNCnNyZWxMb25nJEdvYWw8LW1hcHZhbHVlcyhzcmVsTG9uZyRHb2FsLCBmcm9tID0gYygiR29hbDFTdHJSZWwiLCJHb2FsMlN0clJlbCIsIkdvYWwzU3RyUmVsIiwiR29hbDRTdHJSZWwiLCJHb2FsNVN0clJlbCIsIkdvYWw2U3RyUmVsIiksDQogICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBjKCJHb2FsMSIsIkdvYWwyIiwiR29hbDMiLCJHb2FsNCIsIkdvYWw1IiwiR29hbDYiKSkNCg0KIyMgUmVsZXZhbmNlIG9mIHdlYWtuZXNzIHRvIGVhY2ggcHJvamVjdCANCiMgU2VsZWN0IHZhcnMNCndlYWtEYXRhPC1kYXRhMiAlPiUgZHBseXI6OnNlbGVjdCh0aWR5c2VsZWN0Ojp2YXJzX3NlbGVjdChuYW1lcyhkYXRhMiksIG1hdGNoZXMoJ1dlYWtSZWwnKSkpDQojIEFkZCBQSU4NCndlYWtEYXRhJFBJTjwtZGF0YTIkUElODQojIFdpZGUgdG8gTG9uZw0Kd3JlbExvbmc8LXdlYWtEYXRhICU+JSBnYXRoZXIoR29hbCxXZWFrUmVsLEdvYWwxV2Vha1JlbDpHb2FsNldlYWtSZWwpDQojIFJlbmFtZSBmYWN0b3IgbGV2ZWxzDQp3cmVsTG9uZyRHb2FsPC1tYXB2YWx1ZXMod3JlbExvbmckR29hbCwgZnJvbSA9IGMoIkdvYWwxV2Vha1JlbCIsIkdvYWwyV2Vha1JlbCIsIkdvYWwzV2Vha1JlbCIsIkdvYWw0V2Vha1JlbCIsIkdvYWw1V2Vha1JlbCIsIkdvYWw2V2Vha1JlbCIpLA0KICAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gYygiR29hbDEiLCJHb2FsMiIsIkdvYWwzIiwiR29hbDQiLCJHb2FsNSIsIkdvYWw2IikpDQoNCiMjIFRydXN0IGJlc3QgZnJpZW5kIA0KIyBTZWxlY3QgdmFycw0KdHJ1c3REYXRhPC1kYXRhMiAlPiUgZHBseXI6OnNlbGVjdCh0aWR5c2VsZWN0Ojp2YXJzX3NlbGVjdChuYW1lcyhkYXRhMiksIG1hdGNoZXMoJ1RydXN0QlAnKSkpDQojIEFkZCBQSU4NCnRydXN0RGF0YSRQSU48LWRhdGEyJFBJTg0KIyBXaWRlIHRvIExvbmcNCnRMb25nPC10cnVzdERhdGEgJT4lIGdhdGhlcihHb2FsLFRydXN0LEdvYWwxVHJ1c3RCUDpHb2FsNlRydXN0QlApDQojIFJlbmFtZSBmYWN0b3IgbGV2ZWxzDQp0TG9uZyRHb2FsPC1tYXB2YWx1ZXModExvbmckR29hbCwgZnJvbSA9IGMoIkdvYWwxVHJ1c3RCUCIsIkdvYWwyVHJ1c3RCUCIsIkdvYWwzVHJ1c3RCUCIsIkdvYWw0VHJ1c3RCUCIsIkdvYWw1VHJ1c3RCUCIsIkdvYWw2VHJ1c3RCUCIpLA0KICAgICAgICAgICAgICAgICAgICAgIHRvID0gYygiR29hbDEiLCJHb2FsMiIsIkdvYWwzIiwiR29hbDQiLCJHb2FsNSIsIkdvYWw2IikpDQoNCiMjIFJlbHkgb24gYmVzdCBmcmllbmQgDQojIFNlbGVjdCB2YXJzDQpyZWx5RGF0YTwtZGF0YTIgJT4lIGRwbHlyOjpzZWxlY3QodGlkeXNlbGVjdDo6dmFyc19zZWxlY3QobmFtZXMoZGF0YTIpLCBtYXRjaGVzKCdSZWx5QlAnKSkpDQojIEFkZCBQSU4NCnJlbHlEYXRhJFBJTjwtZGF0YTIkUElODQojIFdpZGUgdG8gTG9uZw0Kckxvbmc8LXJlbHlEYXRhICU+JSBnYXRoZXIoR29hbCxSZWx5LEdvYWwxUmVseUJQOkdvYWw2UmVseUJQKQ0KIyBSZW5hbWUgZmFjdG9yIGxldmVscw0KckxvbmckR29hbDwtbWFwdmFsdWVzKHJMb25nJEdvYWwsIGZyb20gPSBjKCJHb2FsMVJlbHlCUCIsIkdvYWwyUmVseUJQIiwiR29hbDNSZWx5QlAiLCJHb2FsNFJlbHlCUCIsIkdvYWw1UmVseUJQIiwiR29hbDZSZWx5QlAiKSwNCiAgICAgICAgICAgICAgICAgICAgICB0byA9IGMoIkdvYWwxIiwiR29hbDIiLCJHb2FsMyIsIkdvYWw0IiwiR29hbDUiLCJHb2FsNiIpKQ0KYGBgDQoNCk5vdyB0aGF0IHdlJ3ZlIGNyZWF0ZWQgc2V2ZXJhbCBzbWFsbGVyIGRhdGFmcmFtZXMgaW4gKipsb25nIGZvcm1hdCoqLCBsZXQncyBtZXJnZSB0aGVtIHRvZ2V0aGVyIHRvIGNyZWF0ZSBhIGRhdGFmcmFtZSB0aGF0J3MgaW4gKipsb25nIGZvcm1hdCoqIGFuZCBoYXMgYWxsIG9mIG91ciB2YXJpYWJsZXMuIFdoaWxlIHdlJ3JlIGRvaW5nIHRoaXMsIHdlIHdpbGwgY3JlYXRlIGEgY2F0ZWdvcmljYWwgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhIGdvYWwgaXMgb25lIG9mIHRoZSB0aHJlZSBtb3N0IG9yIHRocmVlIGxlYXN0IGltcG9ydGFudCBnb2Fscy4gDQoNCmBgYHtyLCB3YXJuaW5nID0gRkFMU0V9DQojIyMgQ3JlYXRpbmcgV29ya2luZyBMb25nIERhdGENCiMgSW1wb3J0YW5jZSBhbmQgVHJ1c3QNCmltcC50cnVzdDwtbWVyZ2UodExvbmcsaW1wTG9uZyxieT1jKCJHb2FsIiwiUElOIikpDQojIEFkZGluZyByZWx5DQppbXAudHJ1c3QucmVseTwtbWVyZ2UoaW1wLnRydXN0LHJMb25nLGJ5PWMoIkdvYWwiLCJQSU4iKSkNCiMgQWRkaW5nIHJlbGV2YW5jZSB0byBzdHJlbmd0aA0KaW1wLnRydXN0LnJlbHkuc3RyPC1tZXJnZShpbXAudHJ1c3QucmVseSxzcmVsTG9uZyxieT1jKCJHb2FsIiwiUElOIikpDQojIEFkZGluZyByZWxldmFuY2UgdG8gd2Vha25lc3MNCmRhdGEzPC1tZXJnZShpbXAudHJ1c3QucmVseS5zdHIsd3JlbExvbmcsYnk9YygiR29hbCIsIlBJTiIpKQ0KDQojIENvbnZlcnRpbmcgZ29hbCB2YXJpYWJsZSB0byBmYWN0b3IgZm9yIGFuYWx5c2VzDQpkYXRhMyRHb2FsPC1hcy5mYWN0b3IoZGF0YTMkR29hbCkNCg0KIyBBZGRpbmcgRmFjdG9yIEluZGljYXRpbmcgTW9zdCB2cyBMZWFzdCBJbXBvcnRhbnQgUHJvamVjdHMNCmRhdGEzJGltcENhdDwtaWZlbHNlKGRhdGEzJEdvYWw9PSJHb2FsMSIsIDEsDQogICAgICAgICAgICAgIGlmZWxzZShkYXRhMyRHb2FsPT0iR29hbDIiLCAxLA0KICAgICAgICAgICAgICBpZmVsc2UoZGF0YTMkR29hbD09IkdvYWwzIiwgMSwNCiAgICAgICAgICAgICAgaWZlbHNlKGRhdGEzJEdvYWw9PSJHb2FsNCIsIDAsDQogICAgICAgICAgICAgIGlmZWxzZShkYXRhMyRHb2FsPT0iR29hbDUiLCAwLA0KICAgICAgICAgICAgICBpZmVsc2UoZGF0YTMkR29hbD09IkdvYWw2IiwgMCxOQSkpKSkpKQ0KIyBDb252ZXJ0aW5nIHRvIEZhY3Rvcg0KZGF0YTMkaW1wQ2F0PC1hcy5mYWN0b3IoZGF0YTMkaW1wQ2F0KQ0KDQpkYXRhMyRpbXBDYXQ8LWZhY3RvcihkYXRhMyRpbXBDYXQsDQogICAgICAgICAgICAgICAgICAgICBsZXZlbHM9YygwLDEpLA0KICAgICAgICAgICAgICAgICAgICAgbGFiZWxzPWMoIkxlYXN0IEltcG9ydGFudCIsIk1vc3QgSW1wb3J0YW50IikpDQpgYGANCg0KTm93IGxldCdzIGNoZWNrIG91ciBuZXcgZGF0YWZyYW1lIHRvIG1ha2Ugc3VyZSBhbGwgb3VyIHZhcmlhYmxlcyBhcmUgdGhlcmUgYW5kIHRoYXQgdGhleSdyZSBpbiB0aGUgcHJvcGVyIGZvcm1hdC4NCg0KYGBge3IsIHdhcm5pbmcgPSBGQUxTRX0NCnN0cihkYXRhMykNCg0KaGVhZChkYXRhMykNCg0KdGFpbChkYXRhMykNCmBgYA0KDQpOb3cgdGhhdCB3ZSBoYXZlIHRoZSBkYXRhIGluIHRoZSBhcHByb3ByaWF0ZSBmb3JtYXQsIHdlIG9ubHkgaGF2ZSBhIGNvdXBsZSBtb3JlIHByZS1wcm9jZXNzaW5nIHN0ZXBzLiBGaXJzdCwgd2UgbmVlZCB0byBjZW50ZXIgb3VyIHByZWRpY3RvciB2YXJpYWJsZXMuDQoNClRoZXJlIGFyZSB0d28gd2F5cyBJIGNhbiBjaG9vc2UgdG8gY2VudGVyIG15IHByZWRpY3RvciB2YXJpYWJsZXMsIGJ5ICoqcGFydGljaXBhbnQqKiBvciAqKmdsb2JhbGx5KiouICoqR2xvYmFsbHktY2VudGVyZWQqKiB2YXJpYWJsZXMgd2lsbCBzdWJ0cmFjdCB0aGUgKipncmFuZCBtZWFuKiosIG9yIG92ZXJhbGwgYXZlcmFnZSBvZiB0aGUgdmFyaWFibGUsIGZyb20gZWFjaCBwYXJ0aWNpcGFudCdzIHZhbHVlLiBUaGUgZW5kIHJlc3VsdCB3aWxsIGJlIHRoYXQgdGhlIGF2ZXJhZ2UgdmFsdWUgb2YgdGhhdCB2YXJpYWJsZSBhY3Jvc3MgYWxsIHBhcnRpY2lwYW50cyB3aWxsIGJlIDAuICoqUGFydGljaXBhbnQtY2VudGVyZWQqKiB2YXJpYWJsZXMgc3VidHJhY3QgKmVhY2ggcGFydGljaXBhbnQncyogbWVhbiBmcm9tIGVhY2ggb2YgdGhlaXIgdmFsdWVzLiBUaGUgZW5kIHJlc3VsdCBvZiAqdGhpcyogcHJvY2VzcyB3aWxsIGJlIHRoYXQgdGhlIGF2ZXJhZ2UgZm9yIGVhY2ggcGFydGljaXBhbnQgb24gZWFjaCB2YXJpYWJsZSBpcyAwLiBFYWNoIG9mIHRoZXNlIGNlbnRlcmluZyBzdHJhdGVnaWVzIHRlbGxzIGEgZGlmZmVyZW50IHN0b3J5LCBzbyBpdCdzIGltcG9ydGFudCB0byBjaG9vc2Ugd2hpY2hldmVyIG9uZSBtYWtlcyB0aGUgbW9zdCBzZW5zZSBmb3IgeW91ciByZXNlYXJjaCBxdWVzdGlvbi4gSW4gdGhpcyBjYXNlLCAqKnBhcnRpY2lwYW50LWNlbnRlcmVkKiogdmFyaWFibGVzIG1ha2VzIHRoZSBtb3N0IHNlbnNlLiBTbyB0aGF0J3Mgd2hhdCB3ZSdyZSBnb2luZyB0byBkbyENCg0KYGBge3IsIHdhcm5pbmcgPSBGQUxTRX0NCiMjIENlbnRlcmluZyBJVnMgYnkgU3MgDQojIFJlbGV2YW5jZSB0byBTdHJlbmd0aA0KIyBNZWFuIG9mIFJlbGV2YW5jZSB0byBTdHJlbmd0aA0KZGF0YTM8LWRkcGx5KGRhdGEzLC4oUElOKSwgcGx5cjo6bXV0YXRlLCByU3RyTWVhbiA9IG1lYW4oU3RSZWwpKQ0KIyBQYXJ0aWNpcGFudC1jZW50ZXJlZCBSZWxldmFuY2UgdG8gU3RyZW5ndGgNCmRhdGEzJFN0clJlbEM8LWRhdGEzJFN0UmVsLWRhdGEzJHJTdHJNZWFuDQojIEdsb2JhbGx5LWNlbnRlcmVkIFJlbGV2YW5jZSB0byBTdHJlbmd0aA0KZGF0YTMkU3RyUmVsX0dsb2JDIDwtIHNjYWxlKGRhdGEzJFN0UmVsLCBzY2FsZSA9IEZBTFNFKVssXQ0KYGBgDQoNCmBgYHtyLCB3YXJuaW5nID0gRkFMU0UsIGVjaG8gPSBGQUxTRX0NCiMgUmVsZXZhbmNlIHRvIFdlYWtuZXNzDQpkYXRhMzwtZGRwbHkoZGF0YTMsLihQSU4pLCBwbHlyOjptdXRhdGUsIHJXZWFrTWVhbiA9IG1lYW4oV2Vha1JlbCkpDQpkYXRhMyRXZWFrUmVsQzwtZGF0YTMkV2Vha1JlbC1kYXRhMyRyV2Vha01lYW4NCmRhdGEzJFdlYWtSZWxfR2xvYkMgPC0gc2NhbGUoZGF0YTMkV2Vha1JlbCwgc2NhbGUgPSBGQUxTRSlbLF0NCg0KIyBJbXBvcnRhbmNlDQpkYXRhMzwtZGRwbHkoZGF0YTMsLihQSU4pLCBwbHlyOjptdXRhdGUsIEltcEMgPSBtZWFuKEltcG9ydGFuY2UpKQ0KZGF0YTMkSW1wb3J0YW5jZUMgPC1kYXRhMyRJbXBvcnRhbmNlLWRhdGEzJEltcEMNCmRhdGEzJEltcF9HbG9iQyA8LSBzY2FsZShkYXRhMyRJbXBvcnRhbmNlLCBzY2FsZSA9IEZBTFNFKVssXQ0KDQpgYGANCg0KTm93IHRoYXQgd2UndmUgY2VudGVyZWQgb3VyIHByZWRpY3RvcnMsIGxldCdzIGNoZWNrIHdoZXRoZXIgb3VyIHR3byBxdWVzdGlvbnMgdGhhdCBhcmUgdG8gbWFrZSB1cCBvdXIgY29tcG9zaXRlIG1lYXN1cmUgb2YgZ29hbC1zcGVjaWZpYyB0cnVzdCBhcmUgc3VmZmljaWVudGx5IGNvcnJlbGF0ZWQuIEluIG90aGVyIHdvcmRzLCBJIHdhbnQgdG8gYXZlcmFnZSB0aGUgcmVzcG9uc2VzIHRvIHRoZSBxdWVzdGlvbiAiVG8gd2hhdCBleHRlbnQgd291bGQgeW91ICp0cnVzdCogeW91ciBiZXN0IGZyaWVuZCIgd2l0aCB0aGUgcmVzcG9uc2VzIHRvIHRoZSBxdWVzdGlvbiAiVG8gd2hhdCBleHRlbnQgd291bGQgeW91IGJlIHdpbGxpbmcgdG8gKnJlbHkqIG9uIHlvdXIgYmVzdCBmcmllbmQ/IiBIb3dldmVyLCBpZiB0aGVzZSBpdGVtcyBkbyBub3QgYWN0dWFsbHkgbWVhc3VyZSB0aGUgc2FtZSB0aGluZyAoaS5lLiwgdGhlIGNvcnJlbGF0aW9uIGlzIHJlYWxseSBsb3cpLCB0aGVuIEkgc2hvdWxkbid0IGF2ZXJhZ2UgdGhlbSB0b2dldGhlci4gU28gbGV0J3MgbG9vayByZWFsIHF1aWNrLg0KDQpgYGB7ciwgd2FybmluZyA9IEZBTFNFfQ0KY29yLnRlc3QoZGF0YTMkVHJ1c3QsZGF0YTMkUmVseSwgdXNlID0gInBhaXJ3aXNlLmNvbXBsZXRlLm9icyIpDQpgYGANCg0KT2suIFRoZXkncmUgY29ycmVsYXRlZCBhdCBhYm91dCAwLjgwLCB3aGljaCBpcyBub3QgdGhlIGJlc3QsIGJ1dCBpdCBkb2VzIGZhbGwgd2l0aGluIHRoZSByYW5nZSB0aGF0IG1vc3QgY29uc2lkZXIgYXBwcm9wcmlhdGUgZm9yIGF2ZXJhZ2luZy4gU28sIG5vdyBJJ2xsIGRvIHRoYXQgaGVyZS4NCg0KYGBge3IsIHdhcm5pbmcgPSBGQUxTRX0NCmRhdGEzJHRydXN0UmVseSA8LSAoZGF0YTMkVHJ1c3QrZGF0YTMkUmVseSkvMg0KYGBgDQoNClBlcmZlY3QhIE5vdyB3ZSdyZSByZWFkeSB0byBleHBsb3JlIGFuZCBhbmFseXppbmcgb3VyIGRhdGEhDQo8YnIvPjxici8+PGJyLz48YnIvPg0KDQoNCg0KDQojIFBsb3R0aW5nDQpBIGNlbnRyYWwgdGVuZXQgb2YgdGhlIHRoZW9yeSBJJ20gdGVzdGluZyBpcyB0aGF0IHRydXN0IGlzIG5vdCBzdGF0aWMgYWNyb3NzIHRoZSBjb250b3VycyBvZiBhIHJlbGF0aW9uc2hpcC4gSW4gb3RoZXIgd29yZHMsIHBlb3BsZSBjYW4gdHJ1c3QgYW5kIGRpc3RydXN0IHRoZSBzYW1lIHBlcnNvbiBkZXBlbmRpbmcgb24gdGhlIGdvYWwuIElmIHRoYXQncyB0cnVlLCB0aGVuIHdlIHNob3VsZCBiZSBhYmxlIHRvIHNlZSBpdCBpbiBvdXIgZGF0YS4gQmVsb3csIEkgcmFuZG9tbHkgc2VsZWN0IDQgcGFydGljaXBhbnRzIGFuZCBwbG90IHRoZSB0cnVzdCB0aGV5IHBsYWNlIGluIHRoZWlyIGJlc3QgZnJpZW5kIGFjcm9zcyB0aGVpciB0aHJlZSBtb3N0IGFuZCBsZWFzdCBpbXBvcnRhbnQgZ29hbHMNCg0KYGBge3IsICwgZWNobz1GQUxTRSwgb3V0LndpZHRoPScuNDlcXGxpbmV3aWR0aCcsIGZpZy53aWR0aD0zLCBmaWcuaGVpZ2h0PTMuMjUsZmlnLnNob3c9J2hvbGQnLGZpZy5hbGlnbj0nY2VudGVyJ30NCiMgU2V0IHNlZWQgc28gZXZlcnlvbmUgc2VlcyB0aGUgc2FtZSB0aGluZw0Kc2V0LnNlZWQoMTAxKQ0KIyBTYW1wbGUgNCByYW5kb20gUElOUw0KYnlHb2FsU2FtcGxlPC0gc2FtcGxlKGRhdGEzJFBJTiw0KQ0KIyBTdWJzZXQgdGhlIGRhdGEgZm9yIHRoZSA0IHJhbmRvbSBwYXJ0aWNpcGFudHMNCmJ5R29hbFNhbXBsZTI8LWRhdGEzW2RhdGEzJFBJTiAlaW4lIGJ5R29hbFNhbXBsZSxdDQoNCmJ5R29hbDMgPC1nZ3Bsb3QoZGF0YSA9IGJ5R29hbFNhbXBsZTIsIA0KICBhZXMoeCA9IEdvYWwsIHk9dHJ1c3RSZWx5KSkrDQogIGZhY2V0X2dyaWQodmFycyhQSU4pKSsNCiAgZ2VvbV9wb2ludChhZXMoY29sb3VyID0gUElOKSkrDQogIGdlb21fbGluZShhZXMoY29sb3VyID0gUElOLGdyb3VwID0gMSkpKw0KICB4bGFiKCJHb2FsIikreWxhYigiVHJ1c3QiKSsgIyBhZGQgbGFiZWxzDQogIHlsaW0oLTQsIDQpKw0KICB0aGVtZV9idygpKw0KICB0aGVtZShwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoZmlsbCA9IE5BLCBjb2xvdXIgPSAiTkEiKSwNCiAgICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9saW5lKHNpemUgPSAxLCBjb2xvdXIgPSAiZ3JleTgwIiksDQogICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJ0b3AiLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X2JsYW5rKCkpDQpieUdvYWwzDQpgYGANCg0KQi1lLWEtdXRpZnVsISEgV2hlcmVhcyBzb21lIHBlb3BsZSBzZWVtIHRvIGJlIHByZXR0eSBjb25zaXN0ZW50IGluIHRoZWlyIHRydXN0IGluIHRoZWlyIGJlc3QgZnJpZW5kLCBvdGhlcnMgYXBwZWFyIHRvIGNhbGlicmF0ZSB0aGVpciB0cnVzdCBpbiB0aGVpciBmcmllbmQgYWNyb3NzIHRoZSBnb2FscyBpbiB0aGVpciBsaXZlcy4NCg0KTm93IHRoYXQgd2UndmUgY2hlY2tlZCB0byBzZWUgd2hldGhlciB0aGlzIHdhcyBhbGwgcHJvYmFibHkgYSB3YXN0ZSBvZiB0aW1lIG9yIHdoZXRoZXIgdGhlcmUgbWlnaHQgYmUgc29tZW10aGluZyB0aGVyZSwgbGV0J3MgY2hlY2sgb3V0IHRoZSBvdGhlciB2YXJpYWJsZXMuDQo8YnIvPjxici8+PGJyLz4NCg0KDQoNCiMjIEhpc3RvZ3JhbXMNCk9rLCBub3cgdGhhdCB3ZSd2ZSBjZW50ZXJlZCBvdXIgZGF0YSwgbGV0J3MgdGFrZSBhIGxvb2sgYXQgdGhlIGhpc3RvZ3JhbXMgb2Ygb3VyIHZhcmlhYmxlcy4gRmlyc3QsIGxldCdzIGxvb2sgYXQgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgcmVsZXZhbmNlIHRvIHN0cmVuZ3RoIG1lYXN1cmUuDQo8YnIvPjxici8+PGJyLz4NCg0KDQoNCiMjIyBSZWxldmFuY2UgdG8gU3RyZW5ndGgNCmBgYHtyLCAsIGVjaG89RkFMU0UsIG91dC53aWR0aD0nLjQ5XFxsaW5ld2lkdGgnLCBmaWcud2lkdGg9MywgZmlnLmhlaWdodD0zLjI1LGZpZy5zaG93PSdob2xkJyxmaWcuYWxpZ249J2NlbnRlcid9DQpyZWxfc3RyX0hpc3QgPC0gZGF0YTMgJT4lDQogIGdncGxvdChhZXMoeCA9IFN0UmVsKSkgKw0KICBnZW9tX2hpc3RvZ3JhbSgpICsNCiAgeGxhYigiUmVsZXZhbmNlIHRvIFN0cmVuZ3RoIikreWxhYigiQ291bnQiKSArICMgYWRkIGxhYmVscyANCiAgdGhlbWVfYncoKSArDQogIHRoZW1lKHBhbmVsLmdyaWQubWFqb3IgPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLmdyaWQubWlub3IgPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChmaWxsID0gTkEsIGNvbG91ciA9ICJOQSIpLA0KICAgICAgICBheGlzLmxpbmUgPSBlbGVtZW50X2xpbmUoc2l6ZSA9IDEsIGNvbG91ciA9ICJncmV5ODAiKSwNCiAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X2JsYW5rKCkpDQpyZWxfc3RyX0hpc3QNCmBgYA0KDQpUaGF0IGxvb29rcyBkZWNlbnQuIEl0J3MgYSBiaXQgcG9zaXRpdmVseS1za2V3ZWQsIHdoaWNoIG1lYW5zIHRoYXQgdGhlaXIgYXJlIG1vcmUgdmFsdWVzIG9uIHRoZSBsb3dlciBlbmQgb2YgdGhlIHNjYWxlIHRoYW4gdGhlIGhpZ2hlciBlbmQsIGJ1dCBpdCBkb2Vzbid0IGxvb2sgdGVycmlibGUuIE5vdyBsZXQncyB0YWtlIGEgbG9vayBhdCB0aGUgcmVsZXZhbmNlIHRvIHdlYWtuZXNzIG1lYXN1cmUNCjxici8+PGJyLz4NCg0KDQojIyMgUmVsZXZhbmNlIHRvIFdlYWtuZXNzDQpgYGB7ciwgLCBlY2hvPUZBTFNFLCBvdXQud2lkdGg9Jy40OVxcbGluZXdpZHRoJywgZmlnLndpZHRoPTMsIGZpZy5oZWlnaHQ9My4yNSxmaWcuc2hvdz0naG9sZCcsZmlnLmFsaWduPSdjZW50ZXInfQ0KcmVsX3dlYWtfSGlzdCA8LSBkYXRhMyAlPiUNCiAgZ2dwbG90KGFlcyh4ID0gV2Vha1JlbCkpICsNCiAgZ2VvbV9oaXN0b2dyYW0oKSArDQogIHhsYWIoIlJlbGV2YW5jZSB0byBXZWFrbmVzcyIpK3lsYWIoIkNvdW50IikgKyAjIGFkZCBsYWJlbHMgDQogIHRoZW1lX2J3KCkgKw0KICB0aGVtZShwYW5lbC5ncmlkLm1ham9yID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgIHBhbmVsLmdyaWQubWlub3IgPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgcGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGZpbGwgPSBOQSwgY29sb3VyID0gIk5BIiksDQogICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9saW5lKHNpemUgPSAxLCBjb2xvdXIgPSAiZ3JleTgwIiksDQogICAgICAgbGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiLA0KICAgICAgIGxlZ2VuZC50aXRsZSA9IGVsZW1lbnRfYmxhbmsoKSkNCnJlbF93ZWFrX0hpc3QNCmBgYA0KDQpUaGF0IGlzICptdWNoKiB3b3JzZS4gTm90aWNlIGhvdyBuZWFybHkgYWxsIG9mIHRoZSB2YWx1ZXMgYXJlIGF0IHRoZSBsb3dlc3QgZW5kIG9mIHRoZSBzY2FsZT8gTm90IG9ubHkgaXMgdGhpcyBleHRyZW1lbHkgcG9zaXRpdmVseS1za2V3ZWQsIGl0IGFsc28gbG9va3MgbGlrZSB3ZSdyZSBzZWVpbmcgYSAqKmZsb29yIGVmZmVjdCoqLiBBICoqRmxvb3IgZWZmZWN0KiogaXMgd2hlbiB0aGUgZGlzdHJpYnV0aW9uIG9mIHlvdXIgdmFyaWFibGUgaXMgY2x1c3RlcmVkIGF0IHRoZSBsb3dlciBib3VuZCBvZiB0aGUgdmFyaWFibGUgcmFuZ2UuIFRoaXMgaXMgbm90IGEgZ29vZCBkaXN0cmlidXRpb24sIGFuZCBpdCB0ZWxscyB1cyB0aGF0IGFueSBwb3RlbnRpYWwgZmFpbHVyZSB0byBmaW5kIGFuIGVmZmVjdCBtYXkgYmUgZHVlIHRvIHRoZSBoeXBvdGhlc2lzICpvciogdGhlICoqZmxvb3IgZWZmZWN0KiouIFRoYXQncyBub3QgZ29vZCwgYnV0IGl0IGlzIHdoYXQgd2UgaGF2ZSwgc28gd2UnbGwgc2VlIHdoYXQgd2Ugc2VlLg0KDQpGaW5hbGx5LCBsZXQncyBjaGVjayBvdXQgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgY29udGludW91cyBtZWFzdXJlIG9mIGdvYWwgaW1wb3J0YW5jZS4NCjxici8+PGJyLz4NCg0KDQojIyMgR29hbCBJbXBvcnRhbmNlDQpgYGB7ciwgLCBlY2hvPUZBTFNFLCBvdXQud2lkdGg9Jy40OVxcbGluZXdpZHRoJywgZmlnLndpZHRoPTMsIGZpZy5oZWlnaHQ9My4yNSxmaWcuc2hvdz0naG9sZCcsZmlnLmFsaWduPSdjZW50ZXInfQ0KcmVsX3dlYWtfSGlzdCA8LSBkYXRhMyAlPiUNCiAgZ2dwbG90KGFlcyh4ID0gSW1wb3J0YW5jZSkpICsNCiAgZ2VvbV9oaXN0b2dyYW0oKSArDQogIHhsYWIoIkdvYWwgSW1wb3J0YW5jZSIpK3lsYWIoIkNvdW50IikgKyAjIGFkZCBsYWJlbHMgDQogIHRoZW1lX2J3KCkgKw0KICB0aGVtZShwYW5lbC5ncmlkLm1ham9yID0gZWxlbWVudF9ibGFuaygpLA0KICAgICAgIHBhbmVsLmdyaWQubWlub3IgPSBlbGVtZW50X2JsYW5rKCksDQogICAgICAgcGFuZWwuYm9yZGVyID0gZWxlbWVudF9yZWN0KGZpbGwgPSBOQSwgY29sb3VyID0gIk5BIiksDQogICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9saW5lKHNpemUgPSAxLCBjb2xvdXIgPSAiZ3JleTgwIiksDQogICAgICAgbGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiLA0KICAgICAgIGxlZ2VuZC50aXRsZSA9IGVsZW1lbnRfYmxhbmsoKSkNCnJlbF93ZWFrX0hpc3QNCmBgYA0KDQpJbiBjb250cmFzdCB0byB0aGUgbGFzdCB0d28gaGlzdG9ncmFtcywgdGhpcyB2YXJpYWJsZSBpcyBhIGJpdCAqKm5lZ2F0aXZlbHktc2tld2VkKiosIHdoaWNoIG1lYW5zIHRoYXQgbW9zdCBvZiB0aGUgdmFsdWVzIGFyZSBhdCB0aGUgaGlnaGVyIGVuZCBvZiB0aGUgc2NhbGUuIEhvd2V2ZXIsIGxpa2UgdGhlIHJlbGV2YW5jZSB0byBzdHJlbmd0aCBtZWFzdXJlLCB0aGlzIGRpc3RyaWJ1dGlvbiBpcyBub3Qgd29ycmlzb21lLiANCg0KTm93IHRoYXQgd2UndmUgY2hlY2tlZCB0aGUgZGlzdHJpYnV0aW9ucyBvZiBvdXIgcHJlZGljdG9yIHZhcmlhYmxlcywgbGV0J3MgcGxvdCBvdXQgdGhlIHJlbGF0aW9uc2hpcHMgd2UgcGxhbiB0byB0ZXN0Lg0KPGJyLz48YnIvPjxici8+DQoNCg0KDQojIyBQcmVkaWN0ZWQgUmVsYXRpb25zaGlwcw0KQmVmb3JlIHdlIHBsb3QgdGhlIGh5cG90aGVzaXplZCByZWxhdGlvbnNoaXBzLCBsZXQncyBmaXJzdCBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBwYXJ0aWNpcGFudHMnIG1vc3QgaW1wb3J0YW50IGdvYWxzIHdlcmUgYWN0dWFsbHkgbW9yZSBpbXBvcnRhbnQgdGhhbiB0aGVpciBsZWFzdCBpbXBvcnRhbnQgZ29hbHMuDQo8YnIvPjxici8+DQoNCg0KIyMjIE1hbmlwdWxhdGlvbiBDaGVjaw0KYGBge3IsICwgZWNobz1GQUxTRSwgb3V0LndpZHRoPScuNDlcXGxpbmV3aWR0aCcsIGZpZy53aWR0aD0zLCBmaWcuaGVpZ2h0PTMuMjUsZmlnLnNob3c9J2hvbGQnLGZpZy5hbGlnbj0nY2VudGVyJ30NCmltcENoZWNrIDwtIGdncGxvdChkYXRhID0gZGF0YTMsYWVzKHggPSBHb2FsLCB5PUltcG9ydGFuY2VDKSkrDQogIGdlb21fcG9pbnQoYWVzKGNvbG91ciA9IFBJTikpKw0KICBnZW9tX3Ntb290aChtZXRob2QgPSAibG0iLCBzZSA9IFQsIGFlcyhncm91cCA9IGltcENhdCwgY29sb3VyPWltcENhdCkpKw0KICB4bGFiKCJHb2FsIikreWxhYigiSW1wb3J0YW5jZSIpKyAjIGFkZCBsYWJlbHMNCiAgeWxpbSgtNCwgNCkrI3hsaW0oLTQsIDQpKw0KICB0aGVtZV9idygpKw0KICB0aGVtZShwYW5lbC5ncmlkLm1ham9yPWVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgcGFuZWwuZ3JpZC5taW5vcj1lbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChmaWxsID0gTkEsIGNvbG91ciA9ICJOQSIpLA0KICAgICAgICBheGlzLmxpbmUgPSBlbGVtZW50X2xpbmUoc2l6ZSA9IDEsIGNvbG91ciA9ICJncmV5ODAiKSwNCiAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X2JsYW5rKCkpDQppbXBDaGVjaw0KYGBgDQoNClBlcmZlY3QuIFBhcnRpY2lwYW50cyBjb21wbGV0ZWQgdGhlIHN0dWR5IGFzIGV4cGVjdGVkISBOb3cgbGV0J3MgY2hlY2sgb3V0IG91ciBoeXBvdGhlc2VzLg0KDQpUaGUgZmlyc3QgaHlwb3RoZXNpcyB3YXMgdGhhdCBwYXJ0aWNpcGFudHMgd291bGQgdHJ1c3QgdGhlaXIgYmVzdCBmcmllbmQgbGVzcyBmb3IgbW9yZSBpbXBvcnRhbnQgdGhhbiBsZXNzIGltcG9ydGFudCBnb2Fscy4gTGV0J3Mgc2VlIGlmIHRoYXQncyB3aGF0IHRoZSByZWxhdGlvbnNoaXAgbG9va3MgbGlrZS4NCjxici8+PGJyLz4NCg0KDQojIyMgVHJ1c3QgQnkgSW1wb3J0YW5jZQ0KYGBge3IsICwgZWNobz1GQUxTRSwgb3V0LndpZHRoPScuNDlcXGxpbmV3aWR0aCcsIGZpZy53aWR0aD0zLCBmaWcuaGVpZ2h0PTMuMjUsZmlnLnNob3c9J2hvbGQnLGZpZy5hbGlnbj0nY2VudGVyJ30NCiMgR3JhcGhpbmcgVHJ1c3QgYnkgSW1wb3J0YW5jZQ0KSW1wVHJ1c3QgPC0gZ2dwbG90KGRhdGEgPSBkYXRhMywgDQogIGFlcyh4ID0gSW1wb3J0YW5jZUMsIHk9dHJ1c3RSZWx5KSkrDQogICNnZW9tX3BvaW50KGFlcyhjb2xvdXIgPSBQSU4pKSsNCiAgZ2VvbV9zbW9vdGgobWV0aG9kPSJsbSIsIHNlID0gVCkrIywgYWVzKGdyb3VwID0gUElOKSkrIyB3ZSBhZGQgZ3JvdXAgbGV2ZWwNCiAgeGxhYigiSW1wb3J0YW5jZSIpK3lsYWIoIlRydXN0IikrICMgYWRkIGxhYmVscw0KICB5bGltKC00LCA0KSsNCiAgI3hsaW0oLTQsIDQpKw0KICB0aGVtZV9idygpKw0KICB0aGVtZShwYW5lbC5ncmlkLm1ham9yPWVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgcGFuZWwuZ3JpZC5taW5vcj1lbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChmaWxsID0gTkEsIGNvbG91ciA9ICJOQSIpLA0KICAgICAgICBheGlzLmxpbmUgPSBlbGVtZW50X2xpbmUoc2l6ZSA9IDEsIGNvbG91ciA9ICJncmV5ODAiKSwNCiAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gIm5vbmUiLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X2JsYW5rKCkpDQpJbXBUcnVzdA0KYGBgDQoNCldlbGwsIHRoZXJlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIG11Y2ggb2YgYSByZWxhdGlvbnNoaXAgdGhlcmUuIEluIGZhY3QsIGl0IGtpbmRhIGxvb2tzIGxpa2UgdGhlIHNsb3BlIGlzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gdGhhbiBwcmVkaWN0ZWQuIFRoaXMgaXMgZGVmaW5pdGVseSBzb21ldGhpbmcgdG8gbG9vayBmb3IgaW4gdGhlIHN0YXRzIHdlJ2xsIHJ1biBpbiBhIGJpdC4NCg0KVGhlIHNlY29uZCBoeXBvdGhlc2lzIHdhcyB0aGF0IHBhcnRpY2lwYW50cyB3b3VsZCB0cnVzdCB0aGVpciBiZXN0IGZyaWVuZCAqbW9yZSogdGhlIG1vcmUgdGhlaXIgZnJpZW5kJ3Mgc3RyZW5ndGggd2FzIHJlbGV2YW50IHRvIHRoZSBnb2FsLiBMZXQncyB0YWtlIGEgbG9vay4NCjxici8+PGJyLz4NCg0KDQojIyMgVHJ1c3QgQnkgU3RyZW5ndGgNCmBgYHtyLCAsIGVjaG89RkFMU0UsIG91dC53aWR0aD0nLjQ5XFxsaW5ld2lkdGgnLCBmaWcud2lkdGg9MywgZmlnLmhlaWdodD0zLjI1LGZpZy5zaG93PSdob2xkJyxmaWcuYWxpZ249J2NlbnRlcid9DQpyZWxTdHIgPC0gZ2dwbG90KGRhdGEgPSBkYXRhMywgDQogIGFlcyh4ID0gU3RyUmVsQywgeT10cnVzdFJlbHkpKSsgDQogIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsbSIsIHNlID0gVCkrDQogIHhsYWIoIlJlbGV2YW5jZSB0byBTdHJlbmd0aCIpK3lsYWIoIlRydXN0IikrICMgYWRkIGxhYmVscw0KICB5bGltKC00LCA0KSsNCiAgdGhlbWVfYncoKSsNCiAgdGhlbWUocGFuZWwuZ3JpZC5tYWpvcj1lbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLmdyaWQubWlub3I9ZWxlbWVudF9ibGFuaygpLA0KICAgICAgICBwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoZmlsbCA9IE5BLCBjb2xvdXIgPSAiTkEiKSwNCiAgICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9saW5lKHNpemUgPSAxLCBjb2xvdXIgPSAiZ3JleTgwIiksDQogICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJ0b3AiLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X2JsYW5rKCkpDQpyZWxTdHINCmBgYA0KDQpUaGF0IGxvb2tzIGxpa2UgYSBzdHJvbmcgcmVsYXRpb25zaGlwIGluIHRoZSBkaXJlY3Rpb24gd2UgcHJlZGljdGVkISBZYXkhISANCg0KVGhlIHRoaXJkIHByZWRpY3Rpb24gd2FzIHRoYXQgcGFydGljaXBhbnRzIHdvdWxkIHRydXN0IHRoZWlyIGJlc3QgZnJpZW5kICpsZXNzKiB0aGUgbW9yZSB0aGVpciBmcmllbmQncyB3ZWFrbmVzcyB3YXMgcmVsZXZhbnQgdG8gdGhlIGdvYWwuDQo8YnIvPjxici8+DQoNCg0KIyMjIFRydXN0IEJ5IFdlYWtuZXNzDQpgYGB7ciwgLCBlY2hvPUZBTFNFLCBvdXQud2lkdGg9Jy40OVxcbGluZXdpZHRoJywgZmlnLndpZHRoPTMsIGZpZy5oZWlnaHQ9My4yNSxmaWcuc2hvdz0naG9sZCcsZmlnLmFsaWduPSdjZW50ZXInfQ0KcmVsV2VhayA8LSBnZ3Bsb3QoZGF0YSA9IGRhdGEzLCANCiAgYWVzKHggPSBXZWFrUmVsQywgeT10cnVzdFJlbHkpKSsgDQogIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsbSIsIHNlID0gVCkrDQogIHhsYWIoIlJlbGV2YW5jZSB0byBXZWFrbmVzcyIpK3lsYWIoIlRydXN0IikrICMgYWRkIGxhYmVscw0KICB5bGltKC00LCA0KSsNCiAgdGhlbWVfYncoKSsNCiAgdGhlbWUocGFuZWwuZ3JpZC5tYWpvcj1lbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLmdyaWQubWlub3I9ZWxlbWVudF9ibGFuaygpLA0KICAgICAgICBwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoZmlsbCA9IE5BLCBjb2xvdXIgPSAiTkEiKSwNCiAgICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9saW5lKHNpemUgPSAxLCBjb2xvdXIgPSAiZ3JleTgwIiksDQogICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJ0b3AiLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X2JsYW5rKCkpDQpyZWxXZWFrDQpgYGANCg0KVGhhdCBsb29rcyBsaWtlIGEgd2VhayByZWxhdGlvbnNoaXAgYnV0IGFnYWluIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gdGhhbiBwcmVkaWN0ZWQuIFRoaXMgaXMgYW5vdGhlciBmaW5kaW5nIHdlJ2xsIGtlZXAgYSBzaGFycCBleWUgb24gaW4gb3VyIGFuYWx5c2VzLg0KDQpUaGUgZmluYWwgdHdvIGh5cG90aGVzZXMgd2VyZSB0aGF0IHRoZSByZWxhdGlvbnNoaXBzIGJldHdlZW4gdGhlIHJlbGV2YW5jZSB0byBzdHJlbmd0aCBhbmQgdGhlIHJlbGV2YW5jZSB0byB3ZWFrbmVzcyBvbiBnb2FsLXNwZWNpZmljIHRydXN0IHdvdWxkIG9ubHkgc2hvdyB1cCBmb3IgbW9yZSBpbXBvcnRhbnQgZ29hbHMuIFRoZXJlIHNob3VsZCBiZSBubyByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgcmVsZXZhbmNlIHRvIHN0cmVuZ3RoIGFuZCB0aGUgcmVsZXZhbmNlIHRvIHdlYWtuZXNzIG9uIGdvYWwtc3BlY2lmaWMgdHJ1c3QgZm9yIGxlc3MgaW1wb3J0YW50IGdvYWxzLiBOZXh0IEkgcGxvdCB0aG9zZSBwcmVkaWN0aW9ucy4gV2UnbGwgZmlyc3QgdGFrZSBhIGxvb2sgYXQgdGhlIGludGVyYWN0aW9uIGJldHdlZW4gZ29hbCBpbXBvcnRhbmNlIGFuZCB0aGUgcmVsZXZhbmNlIHRvIHN0cmVuZ3RoIGJlZm9yZSBleGFtaW5pbmcgdGhlIGludGVyYWN0aW9uIGJldHdlZW4gZ29hbCBpbXBvcnRhbmNlIGFuZCB0aGUgcmVsZXZhbmNlIHRvIHdlYWtuZXNzLg0KPGJyLz48YnIvPg0KDQoNCiMjIyBJbnRlcmFjdGlvbnMNCmBgYHtyLCAsIGVjaG89RkFMU0UsIG91dC53aWR0aD0nLjQ5XFxsaW5ld2lkdGgnLCBmaWcud2lkdGg9MywgZmlnLmhlaWdodD0zLjI1LGZpZy5zaG93PSdob2xkJyxmaWcuYWxpZ249J2NlbnRlcid9DQpyZWxTdHJJbXAgPC0gZ2dwbG90KGRhdGEgPSBkYXRhMywgDQogIGFlcyh4ID0gU3RyUmVsQywgeT10cnVzdFJlbHkpKSsgDQogIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsbSIsIHNlID0gVCwgYWVzKGdyb3VwID0gaW1wQ2F0LCBjb2xvdXI9aW1wQ2F0KSkrICMgYWRkIGdyb3VwIGxldmVsDQogIHhsYWIoIlJlbGV2YW5jZSB0byBTdHJlbmd0aCIpK3lsYWIoIlRydXN0IikrICMgYWRkIGxhYmVscw0KICB5bGltKC00LCA0KSsNCiAgdGhlbWVfYncoKSsNCiAgdGhlbWUocGFuZWwuZ3JpZC5tYWpvcj1lbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLmdyaWQubWlub3I9ZWxlbWVudF9ibGFuaygpLA0KICAgICAgICBwYW5lbC5ib3JkZXIgPSBlbGVtZW50X3JlY3QoZmlsbCA9IE5BLCBjb2xvdXIgPSAiTkEiKSwNCiAgICAgICAgYXhpcy5saW5lID0gZWxlbWVudF9saW5lKHNpemUgPSAxLCBjb2xvdXIgPSAiZ3JleTgwIiksDQogICAgICAgIGxlZ2VuZC5wb3NpdGlvbiA9ICJ0b3AiLA0KICAgICAgICBsZWdlbmQudGl0bGUgPSBlbGVtZW50X2JsYW5rKCkpDQpyZWxTdHJJbXANCmBgYA0KDQpgYGB7ciwgLCBlY2hvPUZBTFNFLCBvdXQud2lkdGg9Jy40OVxcbGluZXdpZHRoJywgZmlnLndpZHRoPTMsIGZpZy5oZWlnaHQ9My4yNSxmaWcuc2hvdz0naG9sZCcsZmlnLmFsaWduPSdjZW50ZXInfQ0KcmVsV2Vha0ltcCA8LSBnZ3Bsb3QoZGF0YSA9IGRhdGEzLCANCiAgYWVzKHggPSBXZWFrUmVsQywgeT10cnVzdFJlbHkpKSsgDQogIGdlb21fc21vb3RoKG1ldGhvZCA9ICJsbSIsIHNlID0gVCwgYWVzKGdyb3VwID0gaW1wQ2F0LCBjb2xvdXI9aW1wQ2F0KSkrIyB3ZSBhZGQgZ3JvdXAgbGV2ZWwNCiAgeGxhYigiUmVsZXZhbmNlIHRvIFdlYWtuZXNzIikreWxhYigiVHJ1c3QiKSsgIyBhZGQgbGFiZWxzDQogIHlsaW0oLTQsIDQpKw0KICB0aGVtZV9idygpKw0KICB0aGVtZShwYW5lbC5ncmlkLm1ham9yPWVsZW1lbnRfYmxhbmsoKSwNCiAgICAgICAgcGFuZWwuZ3JpZC5taW5vcj1lbGVtZW50X2JsYW5rKCksDQogICAgICAgIHBhbmVsLmJvcmRlciA9IGVsZW1lbnRfcmVjdChmaWxsID0gTkEsIGNvbG91ciA9ICJOQSIpLA0KICAgICAgICBheGlzLmxpbmUgPSBlbGVtZW50X2xpbmUoc2l6ZSA9IDEsIGNvbG91ciA9ICJncmV5ODAiKSwNCiAgICAgICAgbGVnZW5kLnBvc2l0aW9uID0gInRvcCIsDQogICAgICAgIGxlZ2VuZC50aXRsZSA9IGVsZW1lbnRfYmxhbmsoKSkNCnJlbFdlYWtJbXANCmBgYA0KDQpXZWxwLiBJdCBsb29rcyBsaWtlIG5laXRoZXIgcHJlZGljdGlvbiB3YXMgc3VwcG9ydGVkLiBUaW1lIHRvIGdvIHJ1biB0aGUgc3RhdGlzdGljYWwgYW5hbHlzZXMgdG8gY2hlY2sgd2hhdCBvdXIgZ3JhcGhzIGFyZSB0ZWxsaW5nIHVzLg0KPGJyLz48YnIvPjxici8+PGJyLz4NCg0KDQoNCg0KIyBBbmFseXNlcw0KTm93IHRoYXQgd2UndmUgZ3JhcGhlZCBvdXIgZGF0YSBhbmQgZ290dGVuIGluc2lnaHQgaW50byBvdXIgdmFyaWFibGVzJyBkaXN0cmlidXRpb25zIGFuZCB0aGUgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIG91ciBwcmVkaWN0b3IgYW5kIGNyaXRlcmlvbiB2YXJpYWJsZXMsIGl0J3MgdGltZSB0byBydW4gc3RhdGlzdGljYWwgYW5hbHlzZXMgdG8gZm9ybWFsbHkgdGVzdCBvdXIgaHlwb3RoZXNlcy4gDQoNClRoZSBhbmFseXNlcyB0aGF0IEkgd2lsbCBkbyBiZWxvdyBhcmUgbGluZWFyIG11bHRpbGV2ZWwgKG9yIG1peGVkIGVmZmVjdHMpIG1vZGVscyAoTUxNcykuIFRoZXNlIGFuYWx5c2VzIHdpbGwgYWxsb3cgbWUgdG8gbW9kZWwgdGhlIHJhbmRvbSB2YXJpYW5jZSB0aGF0IGlzIGNhdXNlZCBieSBvdXIgcGFydGljaXBhbnRzIHJlcG9ydGluZyBkaWZmZXJlbnQgYXZlcmFnZSBsZXZlbHMgb2YgdHJ1c3QgaW4gdGhlaXIgYmVzdCBmcmllbmQgKHJhbmRvbSBpbnRlcmNlcHQpIGFuZCBkaWZmZXJlbnQgcmVsYXRpb25zaGlwcyBiZXR3ZWVlbiBnb2FsIGltcG9ydGFuY2UgYW5kIGdvYWwtc3BlY2lmaWMgdHJ1c3QgKHJhbmRvbSBzbG9wZSkuIA0KDQpBcyBhIHNpZGUgbm90ZSwgdGhlIG1vc3QgYXBwcm9wcmlhdGUgYW5hbHlzZXMgZm9yIHRoZXNlIGRhdGEgYXJlIGFjdHVhbGx5IG9yZGluYWwgbG9naXN0aWMgbXVsdGlsZXZlbCBtb2RlbHMuIFRoZSBjcml0ZXJpb24gdmFyaWFibGUsIGdvYWwtc3BlY2lmaWMgdHJ1c3QsIGlzIG9uIGFuICoqb3JkaW5hbCBzY2FsZSoqLiBPcmRpbmFsIHNjYWxlcyBhcmUgd2hlcmUgdGhlIGRpc3RhbmNlIGJldHdlZW4gc2NhbGUgcG9pbnRzIGFyZSBub3QgZXZlbi4gQnkgY29udHJhc3QsIGluICoqaW50ZXJ2YWwqKiBvciAqKnJhdGlvIHNjYWxlcyoqLCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzY2FsZSBwb2ludHMgaXMgdGhlIHNhbWUuIEFuIGV4YW1wbGUgb2YgYW4gaW50ZXJ2YWwgc2NhbGUgaXMgdGVtcGVyYXR1cmUgaW4gZGVncmVlcyBGYWhyZW5oZWl0LiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIDEkXlxjaXJjJCBhbmQgMiReXGNpcmMkIEZhaHJlbmhlaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAxMDEkXlxjaXJjJCBhbmQgMTAyJF5cY2lyYyQgRmFocmVuaGVpdC4gQnkgY29udHJhc3QsIGlzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gInNsaWdodGx5IHRydXN0IiBhbmQgIm1vZGVyYXRlbHkgdHJ1c3QiIHRoZSBzYW1lIGFzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gIm1vZGVyYXRlbHkgdHJ1c3QiIGFuZCAidmVyeSBtdWNoIHRydXN0PyIgSSBkb24ndCBrbm93LCBidXQgcHJvYmFibHkgbm90LiBUZWNobmljYWxseSwgbGluZWFyIE1MTXMgcmVxdWlyZSBpbnRlcnZhbCBvciByYXRpbyBjcml0ZXJpb24gdmFyaWFibGVzIHdoZXJlYXMgb3JkaW5hbCBsb2dpc3RpYyBNTE1zIHJlcXVpcmUgb3JkaW5hbCBjcml0ZXJpb24gdmFyaWFibGVzLiBIb3dldmVyLCBJIHJhbiBib3RoIHNldHMgb2YgYW5hbHlzZXMsIGFuZCB0aGUgY29uY2x1c2lvbnMgcmVtYWluIHRoZSBzYW1lLiBDb25zZXF1ZW50bHksIEkgZGVtb25zdHJhdGUgbGluZWFyIE1MTXMgaGVyZSBiZWNhdXNlIHRoZXkgYXJlIGdlbmVyYWxseSBlYXNpZXIgdG8gdW5kZXJzdGFuZC4NCg0KVGhlc2UgYW5hbHlzZXMgYXJlIGEgYml0IGNvbXBsaWNhdGVkIGFuZCByZXF1aXJlIHVzIHRvIGNhcmVmdWxseSBtb25pdG9yIGNoYW5nZXMgaW4gb3VyIG91dHB1dCBhcyBhIGZ1bmNpdG9uIG9mIGNoYW5nZXMgaW4gb3VyIGZpeGVkIGFuZCByYW5kb20gZWZmZWN0cy4gSSB3aWxsIGV4cGxhaW4gZWFjaCBzdGVwLg0KPGJyLz48YnIvPjxici8+DQoNCg0KDQojIyBSYW5kb20gRWZmZWN0cw0KVGhlIGZpcnN0IHN0ZXAgaW4gcnVubmluZyBNTE1zIGlzIHRvIGV4YW1pbmUgeW91ciByYW5kb20gc3RydWN0dXJlLiBUbyBkbyB0aGlzLCB3ZSB3aWxsIGluY2x1ZGUgb25seSB0aGUgY3JpdGVyaW9uIHZhcmlhYmxlIGFuZCBhbiBpbnRlcmNlcHQgaW4gb3VyIG1vZGVsIGFuZCBzeXN0ZW1hdGljYWxseSBjaGFuZ2Ugb3VyIHJhbmRvbSBlZmZlY3RzLiBUaGlzIHBhcnQgbWlnaHQgYmUgYSBiaXQgZWFzaWVyIHRvIHVuZGVyc3RhbmQgd2hpbGUgZG9pbmcgaXQgdGhhbiBtZSBleHBsYWluaW5nIGl0LCBzbyBsZXQncyBqdXN0IGRpdmUgcmlnaHQgaW4uDQoNCkluIHRoaXMgZmlyc3QgbW9kZWwsIEkgYW0gZ29pbmcgdG8gdXNlIHdoYXQncyBjYWxsZWQgdGhlIG1heGltYWwgcmFuZG9tIHN0cnVjdHVyZS4gVGhlIG1heGltYWwgc3RydWN0dXJlIGluY2x1ZGVzIHRoZSByYW5kb20gaW50ZXJjZXB0ICphbmQqIHRoZSByYW5kb20gc2xvcGUsIGFuZCBpcyBvdXIgYmVzdCBtb2RlbCBhdCByZWR1Y2luZyBvdXIgVHlwZSBJIGVycm9yIHJhdGUgKHdoaWNoIGlzIHRoZSBwcm9iYWJpbGl0eSBvZiBpbmNvcnJlY3RseSBzYXlpbmcgdGhlcmUgaXMgYSByZWFsIGVmZmVjdCB3aGVuIHRoZXJlIGlzIGluIGZhY3Qgbm8gZWZmZWN0KS4NCg0KYGBge3J9DQptYXhfcmFuZG9tIDwtIGxtZXIoSW1wb3J0YW5jZSB+IDENCiAgICAgICAgICsgKDErZHVtbXkoaW1wQ2F0KXxQSU4pLCBkYXRhID0gZGF0YTMsIFJFTUw9RikNCnN1bW1hcnkobWF4X3JhbmRvbSkNCmBgYA0KDQpUaGUgZmlyc3QgdGhpbmcgeW91IHNob3VsZCBub3RlIGlzIHRoZSB3YXJuaW5nIHRoYXQgdGhlIG1vZGVsIGZhaWxlZCB0byBjb252ZXJnZS4gVGhpcyBtZWFucyB0aGF0IHRoZSBtYXhpbXVtIGxpa2VsaWhvb2QgZXN0aW1hdGlvbiBwcm9jZXNzIChiZXlvbmQgdGhlIHNjb3BlIG9mIHRoaXMgZXhwbGFuYXRpb24pIGZhaWxlZC4gQSB3aXNlIHBlcnNvbiBvbmNlIHRvbGQgbWUgdGhhdCBhIG1vZGVsIHRoYXQgZG9lcyBub3Qgd29yayBjYW5ub3QgYmUgdGhlIGNvcnJlY3QgbW9kZWwuIEFsdGhvdWdoIHdlJ3JlIGdldHRpbmcgbnVtYmVycyBoZXJlLCBpdCdzIHByb2JhYmx5IGJlc3QgdG8gcmVkdWNlIG91ciByYW5kb20gc3RydWN0dXJlLiAgVGhlIHNlY29uZCB0aGluZyB0byBub3RlIGlzIHRoYXQgdGhlIGNvcnJlbGFpdG9uIGJldHdlZW4gdGhlIHJhbmRvbSBpbnRlcmNlcHQgYW5kIHRoZSByYW5kb20gc2xvcGUgaXMgdmVyeSBoaWdoICgtMC45OSkuIEEgcGVyZmVjdCBjb3JyZWxhdGlvbiAoKy8tIDEuMDApIGlzIHZlcnkgYmFkIGZvciBvdXIgbW9kZWwsIHNvIHRoYXQgZ2l2ZXMgdXMgZnVydGhlciByZWFzb24gdG8gcmVkdWNlIG91ciByYW5kb20gc3RydWN0dXJlLg0KDQpUaGUgdmVyeSBmaXJzdCBjaGFuZ2UgSSBsaWtlIHRvIG1ha2UgaXMgdG8gYmxvY2sgdGhlIGNvcnJlbGF0aW9uIGJldHdlZW4gdGhlIHJhbmRvbSBzbG9wZSBhbmQgaW50ZXJjZXB0LiBUaGlzIHJlbW92ZXMgYSBzaW5nbGUgZmVhdHVyZSBmcm9tIG91ciByYW5kb20gZWZmZWN0cywgc28gaXQgaXMgYSBkZXNpcmFibGUgZmlyc3Qgc3RlcC4gVG8gZG8gdGhpcywgSSdtIGp1c3QgZ29pbmcgdG8gYWRkIGFub3RoZXIgYGBgfGBgYCBpbiB0aGUgcmFuZG9tIGVmZmVjdHMgcG9ydGlvbiBvZiB0aGUgbW9kZWwsIGxpa2UgdGhpcy4NCg0KYGBge3J9DQpub19jb3JfcmFuZG9tIDwtIGxtZXIoSW1wb3J0YW5jZSB+IDENCiAgICAgICAgICsgKDErZHVtbXkoaW1wQ2F0KXx8UElOKSwgZGF0YSA9IGRhdGEzLCBSRU1MPUYpDQpzdW1tYXJ5KG5vX2Nvcl9yYW5kb20pDQpgYGANCg0KVGhhdCB3b3JrZWQhIE5vdGljZSBob3cgd2UgZGlkbid0IGdldCBhbnltb3JlIGVycm9ycz8gVGhpcyByYW5kb20gc3RydWN0dXJlIGRvZXMgc2VlbSB0byBmaXQgb3VyIGRhdGEgYSBiaXQgYmV0dGVyLiBJIGFsc28gd2FudCB5b3UgdG8gbm90aWNlIHRoYXQgdGhlIHJlc2lkdWFsIHZhcmlhbmNlIGluY3JlYXNlZCBldmVyIHNvIHNsaWdodGx5LiBUaGF0J3MgYmVjYXVzZSB3ZSByZW1vdmVkIGEgcmFuZG9tIGVmZmVjdCB0aGF0IHdhcyBhY2NvdW50aW5nIGZvciBzb21lIG9mIHRoZSB2YXJpYW5jZSAodGhlIGNvcnJlbGF0aW9uIGJldHdlZW4gdGhlIHJhbmRvbSBzbG9wZSBhbmQgaW50ZXJjZXB0KS4gSXQncyBpbXBvcnRhbnQgdG8ga2VlcCBhIGNsb3NlIGV5ZSBvbiB5b3VyIHJlc2lkdWFscyBhcyB5b3UgZXhwbG9yZSBkaWZmZXJlbnQgbW9kZWwgZml0cy4NCg0KRGVwZW5kaW5nIG9uIHRoZSB0cmFpbmluZyB5b3UndmUgcmVjZWl2ZWQgaW4gTUxNcywgc29tZSB3b3VsZCBzdG9wIGV4YW1pbmluZyB0aGUgcmFuZG9tIHN0cnVjdHVyZSBoZXJlLiBUaGUgYXJndW1lbnQgZ29lcyB0aGF0IGV2ZXJ5IHJlZHVjdGlvbiBpbiB0aGUgcmFuZG9tIHN0cnVjdHVyZSBoYXMgYSBwb3RlbnRpYWwgKG9yIGluZXZpdGFibGUpIGluY3JlYXNlIGluIHRoZSBUeXBlIEkgZXJyb3IgcmF0ZS4gSG93ZXZlciwgSSB1c2UgcGFyc2ltb25pb3VzIGZpdHRpbmcgKEJhdGVzLCBLbGllZ2wsIFZhc2lzaHRoLCAmIEJhYXllbiwgMjAxNSkgdG8gc3lzdGVtYXRpY2FsbHkgcmVkdWNlIHRoZSByYW5kb20gdGVybXMgYW5kIGZpbmQgdGhlIHNpbXBsZXN0IG1vZGVsIHRoYXQgZG9lcyBub3Qgc2FjcmlmaWNlIG1vZGVsIGZpdC4gVG8gZG8gc28sIEkgd2lsbCByZW1vdmUgcmFuZG9tIGVmZmVjdHMgb25lIGF0IGEgdGltZSBhbmQgc2VlIHRoZSBwb3RlbnRpYWwgY2hhbmdlIGluIHRoZSByZXNpZHVhbCBvZiB0aGUgbW9kZWwuIFRoZSBtb21lbnQgYSBtb2RlbCBmaXRzIHNpZ25pZmljYW50bHkgd29yc2UsIGFzIGRldGVybWluZWQgYnkgYSBDaGktc3F1YXJlLCBJIHdpbGwgc3RvcCBhbmQga2VlcCB0aGUgbW9yZSBjb21wbGV4IG1vZGVsLiBUaGlzIHByb2Nlc3MgY2FuIGJlIGxvbmcsIGFuZCBpdCBpcyBpbmRlZWQgbG9uZyBmb3IgdGhlc2UgZGF0YSwgc28gSSB3aWxsIG9ubHkgc2hvdyB0aGUgZmlyc3Qgc3RlcC4NCg0KSW4gdGhpcyBmaXJzdCBzdGVwLCBJIGFtIGdvaW5nIHRvIHJlbW92ZSB0aGUgcmFuZG9tIGludGVyY2VwdC4gVG8gZXhlY3V0ZSB0aGlzIHN0ZXAsIEkgc2ltcGx5IG5lZWQgdG8gY2hhbmdlIHRoZSAiMSIgaW4gbXkgcmFuZG9tIGVmZmVjdHMgcG9ydGlvbiB0byAiMC4iIExldCdzIHNlZSB3aGF0IGhhcHBlbnMuDQoNCmBgYHtyfQ0Kbm9faW50ZXJjZXB0X3JhbmRvbSA8LSBsbWVyKEltcG9ydGFuY2UgfiAxDQogICAgICAgICArICgwK2R1bW15KGltcENhdCl8fFBJTiksIGRhdGEgPSBkYXRhMywgUkVNTD1GKQ0Kc3VtbWFyeShub19pbnRlcmNlcHRfcmFuZG9tKQ0KYGBgDQoNCk5vdGljZSB0aGF0IHRoZSByZXNpZHVhbCB2YXJpYW5jZSBpbmNyZWFzZWQgYnkgYSBsb3Q/ISBUaGF0IHByb2JhYmx5IG1lYW5zIHRoaXMgbW9kZWwgaXMgbm90IGFzIGdvb2QgYSBmaXQuIExldCdzIGZvcm1hbGx5IHRlc3Qgb3VyIGludHVpdGlvbi4NCg0KYGBge3J9DQphbm92YShub19jb3JfcmFuZG9tLCBub19pbnRlcmNlcHRfcmFuZG9tKQ0KYGBgDQoNCkFzIGV4cGVjdGVkLCB0aGUgbm8gaW50ZXJjZXB0cyBtb2RlbCBmaXRzIHNpZ25pZmljYW50bHkgd29yc2UuIE5vcm1hbGx5LCB0aGF0IHdvdWxkIG1lYW4gdGhhdCBJIHdvdWxkIGtlZXAgdGhlIG1vcmUgY29tcGxleCBtb2RlbC4gSG93ZXZlciwgd2hlbiBJIGFkZGVkIGluIHRoZSBtYWluIGVmZmVjdHMsIHRob3NlIG1vZGVscyBmYWlsZWQgdG8gY29udmVyZ2Ugd2l0aCB0aGUgbW9yZSBjb21wbGV4IHJhbmRvbSBzdHJ1Y3R1cmVzLiBBZnRlciBob3VycyBvZiBwb3VyaW5nIHRocm91Z2ggbWFueSBtYW55IG1vZGVscywgaXQgdHVybmVkIG91dCB0aGF0IHRoZSBzaW1wbGVzdCBtb2RlbCB3YXMgdGhlIG9ubHkgb25lIHRoYXQgY29udmVyZ2VkIGFjcm9zcyBhbGwgYW5hbHlzZXMuIEJlY2F1c2UgeW91ICptdXN0KiBoYXZlIHRoZSBzYW1lIHJhbmRvbSBzdHJ1Y3R1cmUgdG8gY29tcGFyZSBiZXR3ZWVuIG1vZGVscywgdGhhdCBpcyB0aGUgc3RydWN0dXJlIEkgd2lsbCB1c2UgaGVyZS4gVGhlIGZpbmFsIHJhbmRvbSBzdHJ1Y3R1cmUsIHRoZW4sIG9ubHkgaW5jbHVkZXMgYSByYW5kb20gaW50ZXJjZXB0Lg0KDQpOb3cgdGhhdCB3ZSd2ZSBleGFtaW5lZCBvdXIgcmFuZG9tIHN0cnVjdHVyZSwgbGV0J3Mgc3RhcnQgYWN0dWFsbHkgdGVzdGluZyBvdXIgaHlwb3RoZXNlcy4NCjxici8+PGJyLz48YnIvPg0KDQoNCg0KIyMgRml4ZWQgZWZmZWN0cw0KSW4gTUxNcywgZml4ZWQgZWZmZWN0cyByZWZlciB0byB0aGUgZWZmZWN0cyBvZiBpbnRlcmVzdC4gSW4gb3RoZXIgd29yZHMsIG91ciBmaXhlZCBlZmZlY3RzIGFyZSB0aGUgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIG91ciBwcmVkaWN0b3IgdmFyaWFibGVzIGFuZCBvdXIgY3JpdGVyaW9uIHZhcmlhYmxlLiBJbiB0aGUgY2FzZSBvZiB0aGlzIHN0dWR5LCBvdXIgZml4ZWQgZWZmZWN0cyBhcmUgKipnb2FsIGltcG9ydGFuY2UqKiwgKipyZWxldmFuY2UgdG8gc3RyZW5ndGgqKiwgKipyZWxldmFuY2UgdG8gd2Vha25lc3MqKiwgYW5kIHRoZSB0d28td2F5IGludGVyYWN0aW9ucyBiZXR3ZWVuICoqZ29hbCBpbXBvcnRhbmNlKiogYW5kIHRoZSB0d28gKipyZWxldmFuY2UqKiB2YXJpYWJsZXMuIFdlIHdpbGwgbmVlZCBmb3VyIGRpZmZlcmVudCBtb2RlbHMgdG8gZXhhbWluZSBhbGwgb2Ygb3VyIGh5cG90aGVzZXMsIHN0YXJ0aW5nIHdpdGggYSBtb2RlbCB0aGF0IG9ubHkgaW5jbHVkZXMgdGhlIG1haW4gZWZmZWN0cyBvZiBvdXIgcHJlZGljdG9yIHZhcmlhYmxlcy4NCg0KYGBge3J9DQptYWluX2VmZmVjdHMgPC0gbG1lcih0cnVzdFJlbHkgfiBXZWFrUmVsQyArIFN0clJlbEMgKyBpbXBDYXQNCiAgICAgICAgICAgICAgICAgICAgICAgICArICgxfFBJTiksIGRhdGEgPSBkYXRhMywgUkVNTD1GKQ0Kc3VtbWFyeShtYWluX2VmZmVjdHMpDQpgYGANCg0KV2hhdCBkbyB3ZSBub3RpY2U/IEZpcnN0LCBvdXIgcmVsZXZhbmNlIHRvIHN0cmVuZ3RoIG1lYXN1cmUgc3Ryb25nbHkgYW5kIHNpZ25pZmljYW50bHkgcHJlZGljdHMgZ29hbC1zcGVjaWZpYyB0cnVzdC4gVGhpcyB3YXMgdGhlIGVmZmVjdCB3ZSBub3RpY2VkIGluIG91ciBncmFwaHMgYWJvdmUgYW5kIGNvbmZpcm1zIGJvdGggb3VyIGh5cG90aGVzaXMgYW5kIGludHVpdGlvbnMgZnJvbSB0aGUgZ3JhcGguIFNlY29uZCwgYW5kIGluIGxpbmUgd2l0aCB0aGUgZ3JhcGhzIGJ1dCBhZ2FpbnN0IG91ciBoeXBvdGhlc2lzLCBnb2FsIGltcG9ydGFuY2UgaXMgYSBzaWduaWZpY2FudCBhbmQgKnBvc2l0aXZlKiBwcmVkaWN0b3Igb2YgdHJ1c3QsIGFuZCB0aGUgcmVsZXZhbmNlIHRvIHdlYWtuZXNzIGlzIGEgbWFyZ2luYWxseSAodWdoLCBJIGhhdGUgdGhhdCB3b3JkIHRvbykgc2lnbmlmaWNhbnQgYW5kICpwb3NpdGl2ZSogcHJlZGljdG9yIG9mIHRydXN0LiBJJ20gbm90IGdvaW5nIHRvIGdvIHRocm91Z2ggdGhlIGltcGxpY2F0aW9ucyBmb3IgdGhlIHRoZW9yeSBoZXJlLCBzbyBJIGVuY291cmFnZSB5b3UgdG8gcmVhZCBteSBkaXNzZXJ0YXRpb24sIGlmIHlvdSdyZSBpbnRlcmVzdGVkLiA6KQ0KDQpOZXh0LCBsZXQncyBhZGQgZWFjaCBvZiB0aGUgaW50ZXJhY3Rpb25zIGluIG9uZS1hdC1hLXRpbWUuIFdlIHdpbGwgdGVzdCB3aGV0aGVyIHRoZSBtb3JlIGNvbXBsZXggbW9kZWwgZml0cyB0aGUgZGF0YSBiZXR0ZXIgdGhhbiB0aGUgc2ltcGxlciBtb2RlbCBhZnRlciBlYWNoIHN0ZXANCg0KYGBge3J9DQojIyBBZGRpbmcgaW50ZXJhY3Rpb24gYmV0d2VlbiBTdHJlbmd0aCBhbmQgSW1wb3J0YW5jZQ0Kc3RyZW5ndGhfaW1wb3J0YW5jZSA8LSBsbWVyKHRydXN0UmVseSB+IFdlYWtSZWxDICsgU3RyUmVsQyppbXBDYXQNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICgxfFBJTiksIGRhdGE9ZGF0YTMsIFJFTUw9RikNCnN1bW1hcnkoc3RyZW5ndGhfaW1wb3J0YW5jZSkNCiMgVGhlIGludGVyYWN0aW9uIGlzIG5lZ2F0aXZlIGJ1dCBub3Qgc2lnbmlmaWNhbnQNCmFub3ZhKG1haW5fZWZmZWN0cywgc3RyZW5ndGhfaW1wb3J0YW5jZSkNCiMgTm90IGEgc2lnbmlmaWNhbnQgaW1wcm92ZW1lbnQgaW4gbW9kZWwgZml0DQojIyBBZGRpbmcgaW50ZXJhY3Rpb24gYmV0d2VlbiBXZWFrbmVzcyBhbmQgSW1wb3J0YW5jZQ0Kd2Vha25lc3NfaW1wb3J0YW5jZTwtbG1lcih0cnVzdFJlbHkgfiBXZWFrUmVsQyppbXBDYXQgKyBTdHJSZWxDDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoMXxQSU4pLCBkYXRhPWRhdGEzLCBSRU1MPUYpDQpzdW1tYXJ5KHdlYWtuZXNzX2ltcG9ydGFuY2UpDQojIFRoZSBpbnRlcmFjdGlvbiBpcyBub3Qgc2lnbmlmaWNhbnQNCmFub3ZhKG1haW5fZWZmZWN0cywgd2Vha25lc3NfaW1wb3J0YW5jZSkNCiMgTm90IGEgc2lnbmlmaWNhbnQgaW1wcm92ZW1lbnQgaW4gbW9kZWwgZml0DQpgYGANCg0KSW4gY29udHJhc3QgdG8gb3VyIGh5cG90aGVzZXMsIG5laXRoZXIgaW50ZXJhY3Rpb24gaXMgc2lnbmlmaWNhbnQuIEhvd2V2ZXIsIHdlIGhhdmUgb25lIGZpbmFsIG1vZGVsIHRvIHRlc3QgYmVmb3JlIHdlIGdvIGhvbWUuIFdlIHN0aWxsIG5lZWQgdG8gdGVzdCB0aGUgbW9kZWwgd2l0aCBib3RoIGludGVyYWN0aW9ucyBpbmNsdWRlZC4NCg0KYGBge3J9DQojIyBBZGRpbmcgYm90aCBpbnRlcmFjdGlvbnMgZm9yIGNvbXBsZXRlbmVzcw0KZnVsbF9tb2RlbCA8LSBsbWVyKHRydXN0UmVseSB+IFdlYWtSZWxDKmltcENhdCArIFN0clJlbEMqaW1wQ2F0DQogICAgICAgICAgICAgICAgICAgICAgICsgKDF8UElOKSwgZGF0YT1kYXRhMywgUkVNTD1GKQ0Kc3VtbWFyeShmdWxsX21vZGVsKQ0KIyBOZWl0aGVyIGludGVyYWN0aW9uIGlzIHNpZ25pZmljYW50DQphbm92YShzdHJlbmd0aF9pbXBvcnRhbmNlLCBmdWxsX21vZGVsKQ0KYW5vdmEod2Vha25lc3NfaW1wb3J0YW5jZSwgZnVsbF9tb2RlbCkNCiMgTm90IGEgc2lnbmlmaWNhbnQgaW1wcm92ZW1lbnQgaW4gbW9kZWwgZml0IG92ZXIgZWl0aGVyIHNpbmd1bGFyIGludGVyYWN0aW9uIG1vZGVscw0KYGBgDQoNClRoZSBmdWxsIG1vZGVsIGlzIG5vdCBhbiBpbXByb3ZlbWVudCBvdmVyIGVpdGhlciBzaW5nbGUgaW50ZXJhY3Rpb24gbW9kZWxzLg0KPGJyLz48YnIvPjxici8+PGJyLz4NCg0KDQoNCg0KIyBJbXBsaWNhdGlvbnMNClNvIHdoYXQgZGlkIHdlIGxlYXJuPyANCioqRmlyc3QsIHRydXN0IHZhcmllcyB3aXRoaW4gYSByZWxhdGlvbnNoaXAsIGFuZCB0aGF0IHZhcmlhYmlsaXR5IGlzIHByZWRpY3RhYmxlLioqDQoNClNlY29uZCwgdGhlIG1haW4gZWZmZWN0cyBvbmx5IG1vZGVsIHdhcyB0aGUgYmVzdCBmaXQgZm9yIHRoZSBkYXRhLiBDb25zZXF1ZW50bHksIGluIGNvbnRyYXN0IHRvIG91ciBoeXBvdGhlc2VzLCBuZWl0aGVyIG9mIHRoZSBpbnRlcmFjdGlvbnMgYmV0d2VlbiAqKnJlbGV2YW5jZSoqIGFuZCAqKmdvYWwgaW1wb3J0YW5jZSoqIHByZWRpY3QgZ29hbC1zcGVjaWZpYyB0cnVzdC4NCg0KVGhpcmQsICoqcmVsZXZhbmNlIHRvIHdlYWtuZXNzKiogZG9lcyBub3Qgc2lnbmlmaWNhbnRseSBwcmVkaWN0IHRydXN0LCBhbmQgKipnb2FsIGltcG9ydGFuY2UqKiBwb3NpdGl2ZWx5IHByZWRpY3RzIHRydXN0LCBib3RoIG9mIHdoaWNoIGFyZSBjb3VudGVyIHRvIGV4cGVjdGF0aW9ucy4gDQoNCkZvdXJ0aCBhbmQgZmluYWxseSwgYW5kIGluIGxpbmUgd2l0aCBwcmVkaWN0aW9ucywgKipyZWxldmFuY2UgdG8gc3RyZW5ndGgqKiBzdHJvbmdseSBhbmQgcG9zaXRpdmVseSBwcmVkaWN0cyB0cnVzdC4gDQo8YnIvPjxici8+PGJyLz48YnIvPg0KDQoNCg0KDQojIENvbmNsdXNpb24NCkkgaG9wZSB5b3UgaGF2ZSBlbmpveWVkIGFuZCBsZWFybmVkIHNvbWV0aGluZyBmcm9tIHRoaXMgb3ZlcnZpZXcgYW5kIHdhbGt0aHJvdWdoIG9mIG15IGRpc3NlcnRhdGlvbiBsb2dpYyBhbmQgYW5hbHlzZXMhIA0KUGxlYXNlIGZlZWwgZnJlZSB0byBjb250YWN0IG1lIGlmIHlvdSdyZSBpbnRlcmVzdGVkIGluIHRydXN0LCB0aGUgc3RhdHMgcHJlc2VudGVkIGhlcmUsIG9yIGp1c3QgdG8gaGF2ZSBhIGZyaWVuZGx5IGNoYXQhISBJIGxvdmUgbWVldGluZyBuZXcgcGVvcGxlIGFuZCBuZXJkaW5nIG91dCBvbiB0aGVzZSB0b3BpY3Mu</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("dissertation.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
